from OpenGL.GLUT import *
import psl
from psl import *
from psl import drawutils
from psl import fontmanager
import copy
import cPickle
import time
import color_pallet

cocoadialog = '"'+psl.__path__[0]+"/CocoaDialog.app/Contents/MacOS/CocoaDialog"+'"'

import warnings
warnings.filterwarnings("ignore", message="The popen2 module is deprecated.  Use the subprocess module.")

class MouseState:
    
    MOUSE_UP = 2
    MOUSE_DRAGGING_US = 3
    MOUSE_DRAGGING_ELSEWHERE = 4
    MOUSE_HOVER = 5

class MouseTweaker:
    
    MOUSE_UP = 2
    MOUSE_DRAGGING_US = 3
    MOUSE_DRAGGING_ELSEWHERE = 4


    def __init__(self, parent):
        self.radiusSquared = 25
        self.x = 0
        self.y = 0
        self.parent = parent

        self.xCallback = None
        self.yCallback = None

        self.mouseState = MouseTweaker.MOUSE_UP
        self.startx = None
        self.starty = None
    
    def setXCallback(self, xcb):
        self.xCallback = xcb
    
    def setYCallback(self, ycb):
        self.yCallback = ycb
    
    def draw(self):
        glColor3f(1,0,0)
        glRectf(self.x-2,self.y-2,self.x+2,self.y+2)
    
    def handleMouse(self, *args):
        if len(args) == 0:
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:

                if self.xCallback:
                    val = args[0] - self.startx + self.x
                    self.x = self.xCallback(val)
                    self.startx = args[0]

                if self.yCallback:
                    val = args[1] - self.starty + self.y
                    self.y = self.yCallback(val)
                    self.starty = args[1] 

            if self.mouseState == MouseTweaker.MOUSE_UP:
#                print "check mouse", ofDistSquared(args[0],args[1], self.x + self.parent.x, self.y + self.parent.y)
                if ofDistSquared(args[0],args[1], self.x + self.parent.x, self.y + self.parent.y) < self.radiusSquared:
#                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.startx = args[0]
                    self.starty = args[1]
                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
    

def ctrlIsPressed():
    # print "MOD",glutGetModifiers()
    return glutGetModifiers() > 0 #& GLUT_ACTIVE_CTRL

def ctrlIsPressedMod():
    return glutGetModifiers()

class Ruler:
    
    def __init__(self):
        self.x = 0
        self.y = 0
        self.startx = 0
        self.starty = 0        
        self.mouseState = MouseTweaker.MOUSE_UP
    
    def handleMouse(self, *args):
#        print "ruler mouse"
        if len(args) == 0:
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 2:
            self.x = args[0]
            self.y = args[1]            
        if len(args) == 3:
            self.x = args[0]
            self.y = args[1]

            if self.mouseState == MouseTweaker.MOUSE_UP:
                self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                self.startx = args[0]
                self.starty = args[1]
    
    def draw(self):
        glColor3f(0.2, 0.8, 0.2)
        if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
            glBegin(GL_LINES)
            glVertex3f(self.startx, self.starty, 0)
            glVertex3f(self.x, self.y, 0)
            glEnd()
            ofDrawBitmapString("%d, %d" % (self.x - self.startx, self.y - self.starty), self.startx - 20, self.starty - 10)
        glBegin(GL_LINES)
        glVertex3f(self.x - 5, self.y, 0)
        glVertex3f(self.x + 5, self.y, 0)        
        glVertex3f(self.x, self.y - 5, 0)
        glVertex3f(self.x, self.y + 5, 0)        
        glEnd()     
        ofDrawBitmapString("%d, %d" % (self.x, self.y), self.x - 20, self.y - 10)
    

class SelectionManager:
    
    def __init__(self):
        self.selectedObjects = []
    
    def deselectAll(self):
        self.selectedObjects = []
    
    def select(self, obj):
        if obj not in self.selectedObjects:
            self.selectedObjects.append(obj)
    
    def deselect(self, obj):
        if obj in self.selectedObjects:
            self.selectedObjects.remove(obj)
    
    def isSelected(self, obj):
        return obj in self.selectedObjects
    
    def toggleSelection(self, obj):
        if self.isSelected(obj):
            self.deselect(obj)
        else:
            self.select(obj)
    
    def notifyMove(self, obj, x, y):
        for o in self.selectedObjects:
            if o == obj:
                continue
            o.shiftPosition(x, y)
    

class PSGObjectManager:
    
    def __init__(self):
        self.objects = []
        self.ruler = Ruler()
        self.selectionManager = SelectionManager()
        self.enableTweakingFlag = 0
        self.lastMouseX = 0
        self.lastMouseY = 0
        self.dragSelection = False
        self.optionKey = False
        self.arrowDrag = False
        self.alignTool = False
        self.showNames = True
        self.palletHeight = 0
        self.palletScrollBar = None
        self.pallet = None
        self.isRightClickScrolling = False
        self.mouseIsOverNode = False
        self.mouseOnNode = None
        self.hoverNode = None
        self.propertyDrawer = None

        self.rc_px, self.rc_py = 0, 0
    
    def getSelectionManager(self):
        return self.selectionManager
    
    def getMouseLocation(self):
        return self.lastMouseX, self.lastMouseY
    
    def updateDrawOrder(self):
        self.objects.sort()

    def createPropertyDrawer(self):
        self.propertyDrawer = PropertyDrawer()
    
    def addObject(self, o):
        if o not in self.objects:
            self.objects.append(o)
            self.updateDrawOrder()
    
    # def enableTweaking(self):
    #     print "tweaking enabled"
    #     self.enableTweakingFlag = 1
    #     for o in self.objects:
    #         o.enableTweaking = 1
    
    # def disableTweaking(self):
    #     print "tweaking disabled"
    #     self.enableTweakingFlag = 0
    #     for o in self.objects:
    #         o.enableTweaking = 0
    
    def keyPressed(self, key):
        # if key == 101:
        #     self.enableTweaking()
        # if key == 100:
        #     self.disableTweaking()
        pass
    
    def handleMouse(self, *args):

        apply(self.ruler.handleMouse, args)
        if len(args) >= 2:
            self.lastMouseX = args[0]
            self.lastMouseY = args[1]

        self.mouseOnNode = None
        self.hoverNode = None
        for o in reversed(self.objects):
            if apply(o.devHandleMouse,args):
                return

        if len(args) == 0:
            if self.dragSelection == False:
                self.selectionManager.deselectAll()
            self.dragSelection = False
        if self.arrowDrag == False:
            self.checkDragSelection()
    
    def doDragSelection(self):
        self.selectionManager.deselectAll()
        for i in self.objects:
            if self.objInDragBounds(i) and i.draggable:
                self.selectionManager.select(i)
    
    def checkDragSelection(self):
        if self.ruler.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
            if self.ruler.startx > 170 and self.ruler.starty > 20:
                if self.dragSelection == False:
                    self.selectionManager.deselectAll()
                self.dragSelection = True
                self.doDragSelection()
    
    def objInDragBounds(self, obj):
        lowX = min(self.ruler.startx, self.ruler.x)
        highX = max(self.ruler.startx, self.ruler.x)
        lowY = min(self.ruler.starty, self.ruler.y)
        highY = max(self.ruler.starty, self.ruler.y)
        if ofInRange(obj.x + obj.w/2, lowX, highX) and ofInRange(obj.y + obj.h/2, lowY, highY):
            return True
        else:
            return False

    def selectAll(self):
        for o in self.objects:
            if o.draggable:
                self.selectionManager.select(o)
    
    def deleteAllSelected(self):
        for i in self.selectionManager.selectedObjects:
            i.delete()
    
    def drawDragSelection(self):
        ofEnableAlphaBlending()
        ofFill()
        ofSetColor(100, 100, 100, 50)
        ofRect(self.ruler.startx, self.ruler.starty, self.ruler.x - self.ruler.startx, self.ruler.y - self.ruler.starty)
    
    def optionKeyPressed(self):
        self.optionKey = True

    def optionKeyReleased(self):
        self.optionKey = False

    def draw(self):
        for o in self.objects:
            if not o.parent:
                o.devDraw()
        if self.enableTweakingFlag:
            self.ruler.draw()
        if self.dragSelection and self.arrowDrag == False:
            self.drawDragSelection()

    def setMouseOnNode(self, o):
        self.mouseOnNode = o

    def setHoverNode(self, o):
        self.hoverNode = o

    # scroll bar related functions
    def setPalletScrollBar(self, s):
        self.palletScrollBar = s

    def setPallet(self, p):
        self.pallet = p

    def palletSizeUpdate(self, height):
        self.palletHeight = height
        self.palletScrollBar.sizeUpdate(height)
    
    def windowResized(self, w, h):
        self.palletScrollBar.resize(h)
        self.pallet.updateCategoryPositions()

    # right click scrolling!
    def startRightClickScroll(self, x, y):
        self.rc_px, self.rc_py = x, y
        self.isRightClickScrolling = True

    def rightClickScroll(self, x, y):
        dx = x - self.rc_px
        dy = y - self.rc_py
        for o in self.objects:
            if o.draggable:
                o.shiftPosition(dx, dy)
        self.rc_px, self.rc_py = x, y

class PSGObject:
    
    def __init__(self, parent=None):
        self.x = 100
        self.y = 100
        self.w = 100
        self.h = 100
        self.z = 0
        self.zIndex = 0
        self.enableTweaking = 0
        self.parent = parent
        self.children = []
        self.draggable = False
        
        if not self.parent:
            global manager
            manager.addObject(self)
        else:
            self.parent.children.append(self)

        self.posTweaker = MouseTweaker(self)
        self.posTweaker.setXCallback(self._setX)
        self.posTweaker.setYCallback(self._setY)

        self.widthTweaker = MouseTweaker(self)
        self.widthTweaker.x = self.w
        self.widthTweaker.y = -31
        self.widthTweaker.setXCallback(self._setW)

        self.heightTweaker = MouseTweaker(self)
        self.heightTweaker.x = -31
        self.heightTweaker.y = self.h
        self.heightTweaker.setYCallback(self._setH)
    
    def __lt__(self, o):
        return self.zIndex < o.zIndex
    
    def getChildMouseArgs(self, args):
        childArgs = []
        if len(args) == 3:
            cx1 = args[0] - self.x
            cy1 = args[1] - self.y
            childArgs = [cx1, cy1, args[2]]
        if len(args) == 2:
            cx1 = args[0] - self.x
            cy1 = args[1] - self.y
            childArgs = [cx1, cy1]                
        return childArgs
    
    def shiftPosition(self, x,y):
        self.x += x
        self.y += y
    
    def getAbsolutePosition(self):
        x,y = 0,0
        if self.parent:
            x,y = self.parent.getAbsolutePosition()
        return self.x + x, self.y + y
    
    def getPosition(self):
        return self.x, self.y
    
    def setPosition(self, x, y):
        self.x = x
        self.y = y
    
    def _setX(self, x):
        self.x += x
        return 0
    
    def _setY(self, y):
        self.y += y        
        return 0
    
    def _setW(self, w):
        self.w = w
        return self.w
    
    def _setH(self, h):
        self.h = h        
        return self.h    
    
    def devDraw(self):
        self.draw()
        if self.enableTweaking:
            self.drawLayout()
    
    def draw(self):
        ofEnableAlphaBlending()
        glColor4f(1,0,0,0.3)
        glRectf(self.x,self.y, self.x + self.w, self.y + self.h)
        ofDisableAlphaBlending()
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z)
        for c in self.children:
            c.draw()
        glPopMatrix()
    
    def handleMouse(self, *args):
        pass
    
    def devHandleMouse(self, *args):
        if self.enableTweaking:
            self.handleMouseLayout(args)
        else:
            return apply(self.handleMouse, args)
    
    def handleMouseLayout(self, args):
        print "HML",args
        apply(self.posTweaker.handleMouse, args)
        apply(self.widthTweaker.handleMouse, args)
        apply(self.heightTweaker.handleMouse, args)
    
    def drawLayout(self):
        glPushMatrix()
        glTranslatef(self.x, self.y, 0)
        glColor3f(1,1,1)
        str = "x: %d, y: %d" % (self.x, self.y)
        ofDrawBitmapString(str, -20,20)
        glBegin(GL_LINES)

        glVertex3f(0, -29, 0)
        glVertex3f(0, -32, 0)
        glVertex3f(self.w, -29, 0)
        glVertex3f(self.w, -32, 0)
        glVertex3f(0, -31, 0)
        glVertex3f(self.w, -31, 0)

        glVertex3f(-29, 0, 0)
        glVertex3f(-32, 0, 0)
        glVertex3f(-29, self.h, 0)
        glVertex3f(-32, self.h, 0)
        glVertex3f(-31, 0, 0)
        glVertex3f(-31, self.h, 0)

        glEnd()

        str = "w: %d" % (self.w)
        ofDrawBitmapString(str, self.w/2-20,-20)

        str = "h: %d" % (self.h)
        ofDrawBitmapString(str, -20,self.h/2-10)

        self.posTweaker.draw()
        self.widthTweaker.draw()
        self.heightTweaker.draw()
        
        glPopMatrix()
    

class Label(PSGObject):
    
    def __init__(self, parent=None):
        PSGObject.__init__(self, parent)
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.message = ""
        self.theLines = None
        self.lineSpacing = 21
        self.color = (1,1,1)
    
    def setColor(self, c):
        self.color = c
    
    def setLineSpacing(self, s):
        self.lineSpacing = s
    
    def _setW(self, w):
        self.w = w
        self.theLines = None
        return self.w
    
    def setMessage(self, str):
        self.message = str
        self.initLines()
    
    def initLines(self, width = None, recurse = 0):
        if width == None:
            width = self.w
#        print "init lines recurse WIDTH:",width
        self.theLines = []
        words = string.split(self.message)
        count = 1
        while len(words):
            if self.font.stringWidth(string.join(words[:count])) > width or count > len(words):
                if count > 1:
                    count -= 1
                self.theLines.append(string.join(words[:count]))
                words = words[count:]
                count = 0
            count += 1
        if not recurse:
            if len(self.theLines) == 2 and self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1]) > self.font.stringWidth(self.theLines[1]):
                self.initLines(width = self.w - 0.35 * (self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1])), recurse = 1)
                if len(self.theLines) > 2:
                    self.initLines(width = self.w - 0.2 * (self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1])), recurse = 1)
                    if len(self.theLines) > 2:
                        self.initLines(recurse = 1)
        try:
            self.maxLineWidth = max(map(lambda l: self.font.stringWidth(l), self.theLines))
        except:
            print "measure width failed",self.theLines,self.message
    
    def draw(self,opacity = 1):
        if not self.theLines:
            self.initLines()
        glPushMatrix()
        glTranslatef(self.x, self.y + self.lineSpacing, 0)
        apply(glColor3f,self.color)
        for l in self.theLines:
            glPushMatrix()            
            self.font.drawString(l,0,0)
            glPopMatrix()
            glTranslatef(0, self.lineSpacing, 0)
        glPopMatrix()           
    

class Button(PSGObject):
    
    def __init__(self, parent=None):
        PSGObject.__init__(self, parent)
        self.label = None
        self.image = None
        self.fontSize = 11
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",self.fontSize)
        self.callback = None
        self.downCallback = None
        self.hoverCallback = None
        self.endHoverCallback = None
        self.mouseState = 0
        self.lastMouseX = 0
        self.lastMouseY = 0
        self.color = (0.6,0.6,0.6)
        self.showLabel = 0
        self.labelWidth = 0
        self.setLabel("")
        self.draggable = False
    
    def autoSize(self):
        self.w = self.labelWidth + 10
        self.h = self.fontSize + 10
    
    def setLabel(self, l):
        self.label = l
        self.labelWidth = self.font.stringWidth(l)
    
    def setColor(self, c):
        self.color = c
    
    def maybeCallDownCallback(self):
        if self.downCallback:
            self.downCallback()
        else:
            #print "no DOWN callback for button with label",self.label
            pass
    
    def maybeCallHoverCallback(self):
        if self.hoverCallback:
            self.hoverCallback()
    
    def maybeCallEndHoverCallback(self):
        if self.endHoverCallback:
            self.endHoverCallback()
    
    def maybeCallCallback(self):
        if self.callback:
            self.callback()
        else:
            # print "no callback for button with label",self.label
            pass
    
    def handleMouse(self, *args):
        # return 1 if we handled it, 0 otherwise
#        print "button handle mouse",self,args,self.mouseState,self.x, self.y,self.w,self.h
        if len(args) == 0:
            handled = 0
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                 if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
#                     print "do callback"
                     self.maybeCallCallback()
                 handled = 1
            self.mouseState = MouseTweaker.MOUSE_UP
            return handled

        if len(args) == 2:
            if self.mouseState == MouseTweaker.MOUSE_UP:
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
#                    print "hover begin",self
                    self.mouseState = MouseState.MOUSE_HOVER
                    self.maybeCallHoverCallback()
#                    print self,"mouse",self.mouseState
                    return 1

            if self.mouseState == MouseState.MOUSE_HOVER:
                if not (args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h):
#                    print "hover end"
                    self.mouseState = MouseTweaker.MOUSE_UP
                    self.maybeCallEndHoverCallback()
                    return 1
        
        if len(args) == 3:
#            print "mouse state", self.mouseState
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
                if not (self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h):
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0
                return 1

            if self.mouseState in (MouseTweaker.MOUSE_UP, MouseState.MOUSE_HOVER) :
#                print "check mouse", args[0] > self.x, args[0] < self.x + self.w, args[1] > self.y, args[1] < self.y + self.h
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
                    # print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0
    
    def draw(self):
        # DROP SHADOW!!
        d = 3
        
        glColor4f(0, 0, 0, 0.2)
        glBegin(GL_POLYGON)
        glVertex3f(self.x + d, self.y + d, 0)
        glVertex3f(self.x + self.w + d, self.y + d, 0)
        glColor4f(0, 0, 0, 0.2)
        glVertex3f(self.x + self.w + d, self.y + self.h + d, 0)
        glVertex3f(self.x + d, self.y + self.h + d, 0)
        glEnd()

        glBegin(GL_POLYGON)
        if self.showLabel == 1:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                apply(glColor3f, color_pallet.button_down)
            elif self.mouseState == MouseState.MOUSE_HOVER:
                apply(glColor3f, color_pallet.button_highlight)
            else:
                apply(glColor3f, color_pallet.node_top)
        else:
            apply(glColor3f, color_pallet.node_top)
        glVertex3f(self.x, self.y, 0)
        glVertex3f(self.x + self.w, self.y, 0)
        glColor3f(0.3, 0.3, 0.3)
        glVertex3f(self.x + self.w, self.y + self.h, 0)
        glVertex3f(self.x, self.y + self.h, 0)
        glEnd()

        if self.label and self.showLabel:
            glColor3f(1,1,1)
            self.font.drawString(self.label, self.x + self.w/2 - self.labelWidth/2, self.y + self.h/2 + 4)
        if self.image:
            self.image.draw(self.x, self.y)

    def drawHighlight(self):
        apply(glColor3f, color_pallet.node_box_outline_highlight_top)
        glBegin(GL_POLYGON)
        glVertex3f(self.x - 2, self.y - 2, 0)
        glVertex3f(self.x + self.w + 2, self.y - 2, 0)
        apply(glColor4f, color_pallet.node_box_outline_highlight_bottom)
        glVertex3f(self.x + self.w + 2, self.y + self.h + 2, 0)
        glVertex3f(self.x - 2, self.y + self.h + 2, 0)
        glEnd()

    def drawOutline(self, c):
        apply(glColor3f, c)
        glBegin(GL_LINE_LOOP)
        glVertex3f(self.x, self.y, 0)
        glVertex3f(self.x + self.w, self.y, 0)
        glVertex3f(self.x + self.w, self.y + self.h, 0)
        glVertex3f(self.x, self.y + self.h, 0)
        glEnd()
    

def getFilenameToOpen():
    import popen2
    out,junk = popen2.popen2(cocoadialog + " fileselect")
    return out.readline()[:-1]

def doPopupMessage(msg,alt=""):
    import popen2
    if alt == "":
        out,junk = popen2.popen2(cocoadialog + ' ok-msgbox --no-cancel --float --text "'+msg+'"')
    else:
        out,junk = popen2.popen2(cocoadialog + ' ok-msgbox --no-cancel --float --text "'+msg+'" --informative-text "'+alt+'"')
    return out.readline()[:-1]

def getFilenameToSave():
    import popen2
    out,junk = popen2.popen2(cocoadialog + " filesave")
    return out.readline()[:-1]
    


class MenuBar(Button):
    
    #This is not really done
    
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.setPosition(0,0)
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.items = []
        self.currentActiveMenu = None
        self.downCallback = self.maybeActivateMenu
        self.widthPerItem = 80
        self.zIndex = 2
        self.h = 20
    
    def maybeActivateMenu(self):
#        print "maybe activate"
        for i in self.items:
#            print "check",i
            if self.lastMouseX > i.x and self.lastMouseX < i.x + self.widthPerItem:
#                print "activate!!"
                i.activate()
                if self.currentActiveMenu and self.currentActiveMenu != i:
#                    print "deactivate"
                    self.currentActiveMenu.deactivate()
                self.currentActiveMenu = i
#        print "curretn active",self.currentActiveMenu
    
    def addItem(self, i):
        self.items.append(i)
        i.parent = self
        for n in range(len(self.items)):
            self.items[n].x = 15 + self.font.stringWidth(i.name) * n
        # self.w = 15 + self.widthPerItem * (len(self.items) + 1)
        self.w = 30 + self.font.stringWidth(i.name) * (len(self.items) + 1)
    
    def handleMouse(self, *args):
        # return 1 if we handled it, 0 otherwise
#        print "menubar handle mouse"

        if len(args) == 0:
            handled = 0
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
#                print "RELEASE"
                if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
                     if self.currentActiveMenu:
                         self.currentActiveMenu.deactivate()
                         self.currentActiveMenu = None
                else:
                     if self.currentActiveMenu:
#                         print "active handle!"
                         apply(self.currentActiveMenu.handleMouse, self.getChildMouseArgs(args))
                         self.currentActiveMenu.deactivate()
                         self.currentActiveMenu = None
                handled = 1
            self.mouseState = MouseTweaker.MOUSE_UP
            return handled
        if len(args) == 3:
#            print "3 args"
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
#                print "dragging us",self.currentActiveMenu
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
#                print "pre", self.lastMouseX,  self.x, self.x + self.w, self.lastMouseY, self.y, self.y + self.h
                if not ((self.lastMouseX > self.x) and (self.lastMouseX < (self.x + self.w)) and (self.lastMouseY > self.y) and (self.lastMouseY < (self.y + self.h))):
#                    print "BRANCH"
                    if self.currentActiveMenu:
#                        print "active menu"
                        apply(self.currentActiveMenu.handleMouse, self.getChildMouseArgs(args))
#                        print "back from active menu"
                    return 0
                self.maybeActivateMenu()
                return 1

            if self.mouseState == MouseTweaker.MOUSE_UP:
#                print "check mouse", 
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
#                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0
    
    def draw(self):
        # glColor3f(0,0,0)
        # glRectf(0,0,ofGetScreenWidth(),20)
        glBegin(GL_POLYGON)
        # glColor3f(0.3, 0.3, 0.3)
        apply(glColor3f, color_pallet.menubar_top)
        glVertex3f(0, 0, 0)
        glVertex3f(ofGetWidth(), 0, 0)
        # glColor3f(0.1, 0.1, 0.1)
        apply(glColor3f, color_pallet.menubar_bottom)
        glVertex3f(ofGetWidth(), 20, 0)
        glVertex3f(0, 20, 0)
        glEnd()
        for i in self.items:
            i.draw()
    

class MenuItem(PSGObject):
    
    def __init__(self, name, parent=None):
        PSGObject.__init__(self, parent)
        self.setPosition(0,0)
        self.name = name
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.children = []
        self.isActive = 0
        self.w = 160
        self.choiceHeight = 20
        self.headerWidth = self.font.stringWidth(self.name) + 30
        self.currentSelection = None
    
    def activate(self):
        self.isActive = 1
    
    def deactivate(self):
        self.isActive = 0
        if self.currentSelection:
            self.currentSelection.deactivate()
    
    def addItem(self, i):
        self.children.append(i)
        i.parent = self
        for n in range(len(self.children)):
            self.children[n].y = self.choiceHeight + self.choiceHeight * n
    
    def handleMouse(self, *args):
        if self.isActive:
            if len(args) == 2 or len(args) == 3:
                # if mouseX is in range
                if args[0] > self.x and args[0] < self.x + self.w:
                    # get index of menu entry mouseY is within
                    index = (args[1] - self.y) / self.choiceHeight - 1
                    # if the index matches an entry
                    if index < len(self.children) and index >= 0:
                        self.children[index].activate()
                        if self.currentSelection and self.currentSelection != self.children[index]:
                            self.currentSelection.deactivate()
                        self.currentSelection = self.children[index]
                    else:
                        if self.currentSelection:
                            self.currentSelection.deactivate()
                else:
                    if self.currentSelection:
                        self.currentSelection.deactivate()

            if len(args) == 0:
                for c in self.children:
                    if c.isActive:
                        c.maybeCallCallback()
                        c.deactivate()
                self.deactivate()
    
    def draw(self):
        glPushMatrix()
        glColor3f(0.8, 0.8, 0.8)
        glTranslatef(self.x, self.y, 0)
        if self.isActive:
            glColor3f(0.2, 0.2, 0.2)
            glRectf(0,self.choiceHeight,self.w,self.choiceHeight+self.choiceHeight*len(self.children))

            glBegin(GL_POLYGON)
            glColor3f(0.2, 0.2, 0.2)
            glVertex3f(7, 0, 0)
            glVertex3f(self.headerWidth - 7, 0, 0)
            glColor3f(0, 0, 0)
            glVertex3f(self.headerWidth - 7, self.choiceHeight, 0)
            glVertex3f(7, self.choiceHeight, 0)
            glEnd()

            # glRectf(0,0,self.headerWidth,self.choiceHeight)
            for c in self.children:
                c.draw()
        
        glColor3f(0.8, 0.8, 0.8)
        self.font.drawString(self.name, 15, self.choiceHeight-5)
        glPopMatrix()
    

class MenuEntry(PSGObject):
    
    def __init__(self, name, callback, parent=None):
        PSGObject.__init__(self, parent)
        self.setPosition(0,0)
        self.name = name
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.isActive = 0
        self.w = 160
        self.h = 20
        self.callback = callback
    
    def maybeCallCallback(self):
#        print "selected menu entry",self.name
        if self.callback:
            self.callback()
    
    def activate(self):
        self.isActive = 1
    
    def deactivate(self):
        self.isActive = 0

    def mouseOver(self, x, y):
        return self.x < x < self.x + self.w and self.y < y < self.y + self.h
    
    def draw(self):
        glPushMatrix()
        glTranslatef(self.x, self.y, 0)
        if self.isActive:
            # glColor3f(0.6,0.3,0.3)
            # glRectf(0, 0, self.w, self.h)
            glBegin(GL_POLYGON)
            glColor3f(0.7, 0.4, 0.4)
            glVertex3f(0, 0, 0)
            glVertex3f(self.w, 0, 0)
            glColor3f(0.6, 0.3, 0.3)
            glVertex3f(self.w, self.h, 0)
            glVertex3f(0, self.h, 0)
            glEnd()
        glColor3f(0.8, 0.8, 0.8)
        self.font.drawString(self.name, 10, 15)
        glPopMatrix()      
    

class UndoManager:
    
    def __init__(self):
        self.maxSteps = 20
        self.undoState = []
        self.redoState = []
        self.storeCallback = None
    
    def checkpoint(self):
        if self.storeCallback:
            self.storeCallback()
    
    def setStoreCallback(self, c):
        self.storeCallback = c
    
    def store(self, state):
        
        if len(self.undoState) and state == self.undoState[-1]:
            #print "no change, no undo checkpoint."
            return
        # print "ADD UNDO STATE"

        self.undoState.append(state)
        while len(self.undoState) > self.maxSteps:
            del(self.undoState[0])
    
    def canUndo(self):
        return len(self.undoState) > 0
    
    def canRedo(self):
        return len(self.redoState) > 0
    
    def undo(self):
        # print "GET UNDO STATE"
        if not self.canUndo():
            return None
        self.checkpoint()
        forRedo = self.undoState[-1]
        del(self.undoState[-1])
        state = self.undoState[-1]
        self.redoState.append(forRedo)
        del(self.undoState[-1])
        return state
    
    def redo(self):
        # print "GET REDO STATE"
        if not self.canRedo():
            return None
        self.checkpoint()
        state = self.redoState[-1]
        del(self.redoState[-1])
        return state
    

undo = UndoManager()

class Window(Button):
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.label = "to be named"
        self.visible = 0
        self.zIndex = 0.5
    
    def show(self):
        self.visible = 1
    
    def validate(self):
        for c in self.children:
            if c.__class__ == TextEntry or c.__class__ == InteractiveTextfield:
                if c.needsValidation:
                    if c.doValidation():
                        return 1
    
    def hide(self):
        if not self.validate():
            self.visible = 0
            for c in self.children:
                if c.__class__ == TextEntry or c.__class__ == InteractiveTextfield:
                    global focus
                    if focus.doIHaveFocus(c):
                        focus.release(c)
                        # print "released focus for", c
                        return
    
    def addInput(self, i):
        self.inputs.append(i)
        self.doConnectionLayout()
    
    def addOutput(self, o):
        self.outputs.append(o)
        self.doConnectionLayout()
    
    def doConnectionLayout(self):
        for i in self.inputs:
            i.setPosition(0,-7)
        for o in self.outputs:
            o.setPosition(0,self.h/2)            
    
    def handleMouse(self, *args):

        if not self.visible:
            return

        if len(self.children):
            childArgs = []
            if len(args) == 3:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1, args[2]]
            if len(args) == 2:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1]                
            for c in self.children:
                if apply(c.handleMouse, childArgs):
                    return 1
            

        if len(args) == 0:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                 if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
                     self.maybeCallCallback()
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                if self.lastMouseX or self.lastMouseY:
                    self.x += args[0] - self.lastMouseX
                    self.y += args[1] - self.lastMouseY
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
                return 1

            if self.mouseState == MouseTweaker.MOUSE_UP:
                # print "check mouse", 
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
                    # print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
    
    def draw(self):
        
        if not self.visible:
            return
        
        if self.mouseState ==  MouseTweaker.MOUSE_DRAGGING_US:
            glColor3f(0.35,0.35,0.35)
        else:
            glColor3f(0.3,0.3,0.3)            
        # drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 5)

        # glBegin(GL_POLYGON)
        
        # glVertex3f(self.x, self.y, 0)
        # glVertex3f(self.x + self.w, self.y, 0)
        # glColor3f(0.3, 0.3, 0.3)
        # glVertex3f(self.x + self.w, self.y + self.h, 0)
        # glVertex3f(self.x, self.y + self.h, 0)
        # glEnd()

        # glColor3f(0.8, 0.8, 0.8)
        # glRectf(self.x, self.y - 15, self.x + self.w, self.y)

        # apply(glColor3f, self.color)
        glRectf(self.x, self.y, self.x + self.w, self.y + self.h)

        glPushMatrix()
        glTranslatef(self.x, self.y, self.z)
        for c in self.children:
            c.draw()
        glPopMatrix()


class TextField(Button):
    
    NONE = 0
    NUMBER = 1
    
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.callback = self.askForFocus
        self.currentText = ""
        self.shortenDict = {}
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 20
        self.shouldValidate = TextEntry.NONE
        self.needsValidation = 0
    
    def setValidate(self, f):
        self.shouldValidate = f
    
    def validateAsNumber(self):
        self.setValidate(TextEntry.NUMBER)
    
    def doValidation(self):
        status = 1
        if self.shouldValidate == TextEntry.NUMBER:
            try:
                string.atof(self.currentText)
                status = 0
            except:
                doPopupMessage("Please enter a number.","The text '"+self.currentText+"' does not seem to be a number.")
                self.currentText = "0"
                
        self.needsValidation = 0
        self.askForFocus()
        return status
    
    def askForFocus(self):
        global focus
        focus.claim(self)
    
    def getShortVersion(self, text):
        if self.shortenDict.has_key(text):
            return self.shortenDict[text]
        else: 
            if self.font.stringWidth(text) < (self.w - 10):
                self.shortenDict[text] = text
                return self.shortenDict[text]
            start = 0
            while self.font.stringWidth("..."+text[start:]) > (self.w - 10):
                start += 1
            self.shortenDict[text] = "..."+text[start:]
            return self.shortenDict[text]
    
    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1,1,1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)
        glLineWidth(1)
        glBegin(GL_LINE_STRIP)
        glVertex3f(self.x, self.y, self.z)
        glVertex3f(self.x+self.w, self.y, self.z)
        glVertex3f(self.x+self.w, self.y+self.h, self.z)
        glVertex3f(self.x, self.y+self.h, self.z)
        glVertex3f(self.x, self.y, self.z)
        glEnd()
        stringToDraw = ""
        if time.time() % 1 > 0.5 and focus.doIHaveFocus(self):
            stringToDraw = self.getShortVersion(self.currentText) + "_"
        else:
            stringToDraw = self.getShortVersion(self.currentText)
        self.font.drawString(stringToDraw, self.x + 2, self.y + self.h - 5)
    
    def keyPressed(self, key):
        # if key == 8:
        #     manager.deleteAllSelected()
        if key == 127: #backspace
            self.currentText = self.currentText[:-1]
            self.needsValidation = 1
            return
        if key == 13 or key == 27: #return or escape
            focus.release(self)
            self.parent.hide()
            return
        if key < 256: #if key is within chr range (0 - 255) (fixes crash-on-arrow-key bug)
            self.currentText += chr(key)
        self.needsValidation = 1


class InteractiveTextfield(Button):

    NONE = 0
    NUMBER = 1

    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.callback = self.askForFocus
        self.currentText = ""
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 20
        self.xOffset, self.yOffset = 2, self.h - 5
        self.cPos = self.x + self.xOffset
        self.caretIndex = 0
        self.oldCaretIndex = 0
        self.highlight = None
        self.lastEvent = time.time()
        #
        self.shouldValidate = TextEntry.NONE
        self.needsValidation = 0

    def setValidate(self, f):
        self.shouldValidate = f
    
    def validateAsNumber(self):
        self.setValidate(TextEntry.NUMBER)

    def doValidation(self):
        status = 1
        if self.shouldValidate == TextEntry.NUMBER:
            try:
                float(self.currentText)
                status = 0
            except:
                doPopupMessage("Please enter a number.","The text '"+self.currentText+"' does not seem to be a number.")
                self.currentText = "0"
                
        self.needsValidation = 0
        self.askForFocus()
        return status

    def askForFocus(self):
        global focus
        focus.claim(self)

    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1, 1, 1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)
        glLineWidth(1)
        glBegin(GL_LINE_STRIP)
        glVertex3f(self.x, self.y, self.z)
        glVertex3f(self.x+self.w, self.y, self.z)
        glVertex3f(self.x+self.w, self.y+self.h, self.z)
        glVertex3f(self.x, self.y+self.h, self.z)
        glVertex3f(self.x, self.y, self.z)
        glEnd()

        if focus.doIHaveFocus(self):
            self.drawCaret()
            if self.highlight:
                self.drawHighlight()

        if focus.doIHaveFocus(self):
            glColor3f(1, 1, 1)
        else:
            glColor3f(0.75, 0.75, 0.75)

        self.font.drawString(self.currentText, self.x + self.xOffset, self.y + self.yOffset)

    def drawCaret(self):
        if self.currentText != "":
            widthOfSubsection = self.getWidthForPosition()
            self.cPos = self.x + self.xOffset + widthOfSubsection + 1
        else:
            self.cPos = self.x + self.xOffset + 1
        if (time.time() - self.lastEvent) % 1 < 0.5:
            glBegin(GL_LINES)
            glVertex3f(self.cPos, self.y + 2, 0)
            glVertex3f(self.cPos, self.y + self.yOffset + 2, 0)
            glEnd()

    def drawHighlight(self):
        tempString = self.currentText.replace(" ", "_")
        x = self.font.stringWidth(tempString[:self.highlight[0]])
        width = self.font.stringWidth(tempString[self.highlight[0]:self.highlight[1]])
        glColor4f(0.7, 1, 1, 0.3)
        glRectf(self.x + x + 2, self.y + 2, self.x + x + width + 3, self.y + self.yOffset + 1)

    def getWidthForPosition(self):
        tempString = self.currentText[0:self.caretIndex]
        tempString = tempString.replace(" ", "_")
        return self.font.stringWidth(tempString)

    def getWidthForHighlight(self):
        tempString = self.currentText[self.highlight[0]:self.hightlight[1]]
        tempString = tempString.replace(" ", "_")
        return self.font.stringWidth(tempString)

    def keyPressed(self, key):
        self.lastEvent = time.time()
        if key == 127: #backspace
            self.needsValidation = 1
            if self.highlight:
                self.currentText = self.currentText[0:self.highlight[0]] + self.currentText[self.highlight[1]:]
                self.caretIndex = self.highlight[0]
                self.highlight = None
            else:
                if self.caretIndex < len(self.currentText):
                    self.currentText = self.currentText[0:self.caretIndex - 1] + self.currentText[self.caretIndex:]
                else:
                    self.currentText = self.currentText[:-1]
                self.needsValidation = 1
                if self.caretIndex > 0:
                    self.caretIndex -= 1
            return
        if key == 356 and glutGetModifiers() == 1: # shift + left arrow
            if self.highlight == None and self.caretIndex > 0:
                self.caretIndex -= 1
                self.highlight = [self.caretIndex, self.caretIndex + 1]
            elif self.caretIndex > 0:
                if self.highlight[0] == self.caretIndex:
                    self.caretIndex -= 1
                    self.highlight[0] = self.caretIndex
                elif self.highlight[1] == self.caretIndex:
                    self.caretIndex -= 1
                    self.highlight[1] = self.caretIndex
                if self.highlight[0] == self.highlight[1]:
                    self.highlight = None
            return
        if key == 358 and glutGetModifiers() == 1: # shift + right arrow
            if self.highlight == None and self.caretIndex < len(self.currentText):
                self.caretIndex += 1
                self.highlight = [self.caretIndex - 1, self.caretIndex]
            elif self.caretIndex < len(self.currentText):
                if self.highlight[0] == self.caretIndex:
                    self.caretIndex += 1
                    self.highlight[0] = self.caretIndex
                elif self.highlight[1] == self.caretIndex:
                    self.caretIndex += 1
                    self.highlight[1] = self.caretIndex
                if self.highlight[0] == self.highlight[1]:
                    self.highlight = None
            return
        if key == 356: # left arrow
            if self.highlight:
                self.caretIndex = self.highlight[0]
                self.highlight = None
            elif self.caretIndex > 0:
                self.caretIndex -= 1
            return
        if key == 358: # right arrow
            if self.highlight:
                self.caretIndex = self.highlight[1]
                self.highlight = None
            elif self.caretIndex < len(self.currentText):
                self.caretIndex += 1
            return
        if key == 13 or key == 27: #return or escape
            if self.doValidation() == 0 or self.shouldValidate == TextEntry.NONE:
                focus.release(self)
                self.parent.hide()
                self.caretIndex = len(self.currentText)
            return
        if key < 256: #if key is within chr range (0 - 255) (fixes crash-on-arrow-key bug)
            self.needsValidation = 1
            if self.highlight:
                self.currentText = self.currentText[0:self.highlight[0]] + self.currentText[self.highlight[1]:]
                self.caretIndex = self.highlight[0]
                self.highlight = None
            if self.caretIndex < len(self.currentText):
                tempString = (self.currentText[0:self.caretIndex], self.currentText[self.caretIndex:])
                self.currentText = tempString[0] + chr(key) + tempString[1]
            else:
                self.currentText += chr(key)
            self.caretIndex += 1

    def handleMouse(self, *args):
        # return 1 if handled, else 0
        if len(args) == 0:
            # mouse was just released
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.mouseState = MouseTweaker.MOUSE_UP
                self.mouseReleased()
                return 1
        if len(args) == 2:
            # moving
            if self.x < args[0] < self.x + self.w and self.y < args[1] < self.y + self.h:
                self.mouseState = MouseState.MOUSE_HOVER
                return 1
            else:
                self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            # mouse is either pressed or dragging.
            # if it has been pressed:
            if self.mouseState == MouseState.MOUSE_HOVER:
                self.mousePressed(args[0], args[1])
                self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                return 1
            elif self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.mouseDrag(args[0], args[1])
                return 1

    def mousePressed(self, x, y):
        self.askForFocus()
        xPos = x - self.x
        sum, returnPosition = 0, len(self.currentText)
        tempString = self.currentText.replace(" ", "_")
        for i in range(len(tempString)):
            sum = self.font.stringWidth(tempString[:i+1])
            if sum > xPos:
                returnPosition = i
                break
        self.caretIndex = returnPosition
        self.oldCaretIndex = returnPosition
        self.lastEvent = time.time()

    def mouseReleased(self):
        pass

    def mouseDrag(self, x, y):
        xPos = x - self.x
        sum, returnPosition = 0, len(self.currentText)
        tempString = self.currentText.replace(" ", "_")
        # rather than summing individual characters, grab
        # successively larger chunks of text. otherwise we do
        # not account for letter tracking.
        for i in range(len(tempString)):
            sum = self.font.stringWidth(tempString[:i+1])
            if sum > xPos:
                returnPosition = i
                break
        self.caretIndex = returnPosition
        self.highlight = [self.caretIndex, self.oldCaretIndex]
        if self.highlight[0] == self.highlight[1]:
            self.highlight = None
        else:
            self.highlight.sort()
        self.lastEvent = time.time()


class TextEntry(Button):

    NONE = 0
    NUMBER = 1

    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.callback = self.askForFocus

        # TEXT
        self.currentText = ""
        self.subText = ""
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.formatThisFrame = True

        # SIZE + POSITION
        self.h = 20
        self.xOffset, self.yOffset = 2, self.h - 5

        # CARET
        self.caretIndex = 0
        self.oldCaretIndex = 0
        self.caretPixelPosition = self.x + self.xOffset

        # HIGHLIGHT
        # - describes a subset of self.currentText to be highlighted.
        #   if no highlight, it should = None
        self.highlight = None

        # WINDOW BOUNDS
        # - describes a subset of self.currentText that will be shown in
        #   the textfield. If no subset is necessary, it should = None
        self.windowBounds = None

        # this ensures that the caret blink resets everytime something happens
        self.lastEvent = time.time()
        # this will be used to advance the window bounds while dragging.
        self.lastMouseEvent = time.time()

        # VALIDATION
        self.shouldValidate = TextEntry.NONE
        self.needsValidation = 0

    def setValidate(self, f):
        self.shouldValidate = f
    
    def validateAsNumber(self):
        self.setValidate(TextEntry.NUMBER)

    def doValidation(self):
        status = 1
        if self.shouldValidate == TextEntry.NUMBER:
            try:
                float(self.currentText)
                status = 0
            except:
                doPopupMessage("Please enter a number.","The text '"+self.currentText+"' does not seem to be a number.")
                self.currentText = "0"
                
        self.needsValidation = 0
        self.askForFocus()
        return status

    def askForFocus(self):
        global focus
        focus.claim(self)

    def setText(self, t):
        self.currentText = t
        self.formatText("RIGHT")

    def formatText(self, anchor = "RIGHT"):
        tempText = self.noSpaces(self.currentText)
        # RIGHT anchor
        if anchor == "RIGHT":
            if self.font.stringWidth(tempText) > self.w - 10:
                if self.windowBounds:
                    # if there are window boundaries, anchor to the right side
                    # make subText the full text so that it enters the while loop correctly
                    self.subText = tempText
                    start = 0
                    # clear text from the left side until it's the right size
                    while self.font.stringWidth(self.subText) > self.w - 10:
                        start += 1
                        # using tempText because stringWidth doesn't like spaces.
                        self.subText = tempText[start:self.windowBounds[1]]
                    # set new left boundary
                    self.windowBounds[0] = start
                    # since we used tempText to calculate length, replace it with the actual text now
                    self.subText = self.currentText[self.windowBounds[0]:self.windowBounds[1]]
                else:
                    # no window boundaries to work with
                    start = 0
                    self.subText = tempText
                    while self.font.stringWidth(self.subText) > self.w - 10:
                        start += 1
                        self.subText = tempText[start:]
                    # now we have boundaries
                    self.windowBounds = [start, len(self.currentText)]
                    # populate subText with the actual text
                    self.subText = self.currentText[self.windowBounds[0]:self.windowBounds[1]]
            else:
                self.windowBounds = None
        if anchor == "LEFT":
            # same as above but starting from the left side
            if self.font.stringWidth(tempText) > self.w - 10:
                if self.windowBounds:
                    self.subText = tempText[self.windowBounds[0]:]
                    end = len(tempText)
                    while self.font.stringWidth(self.subText) > self.w - 10:
                        end -= 1
                        self.subText = tempText[self.windowBounds[0]:end]
                    self.windowBounds[1] = end
                    self.subText = self.currentText[self.windowBounds[0]:self.windowBounds[1]]
                else:
                    self.subText = tempText
                    end = len(tempText)
                    while self.font.stringWidth(self.subText) > self.w - 10:
                        end -= 1
                        self.subText = tempText[:end]
                    self.windowBounds = [0, end]
                    self.subText = self.currentText[self.windowBounds[0]:self.windowBounds[1]]
            else:
                self.windowBounds = None

    def noSpaces(self, t):
        return t.replace(" ", "_")

    def getCaretPixelPosition(self):
        # if there are window bounds, offset by the boundary and use subText to find caretPixelPosition
        # else, get it using currentText
        if len(self.currentText) > 0:
            if self.windowBounds:
                tempSubText = self.noSpaces(self.subText)
                self.caretPixelPosition = self.x + self.xOffset + self.font.stringWidth(tempSubText[:self.caretIndex - self.windowBounds[0]]) + 1
                return
            else:
                tempText = self.noSpaces(self.currentText)
                self.caretPixelPosition = self.x + self.xOffset + self.font.stringWidth(tempText[0:self.caretIndex]) + 1
                return
        else:
            self.caretPixelPosition = self.x + self.xOffset + 1

    def drawCaret(self):
        if (time.time() - self.lastEvent) % 1 < 0.5:
            self.getCaretPixelPosition()
            glBegin(GL_LINES)
            glVertex3f(self.caretPixelPosition, self.y + 2, 0)
            glVertex3f(self.caretPixelPosition, self.y + self.yOffset + 2, 0)
            glEnd()

    def drawHighlight(self):
        if self.windowBounds:
            tempSubString = self.noSpaces(self.subText)
            # make a temp highlight in case the current highlight exceeds the window bounds
            # (since we are only showing the part of the highlight that is currently on the screen)
            # # tempHighlight = [ min(self.highlight[0] - self.windowBounds[0], 0), min(self.highlight[1] - self.windowBounds[1], len(self.subText))
            _x = max(self.highlight[0] - self.windowBounds[0], 0)
            x = self.font.stringWidth(tempSubString[:_x])
            _width = min(self.highlight[1] - self.windowBounds[0], len(self.subText))
            width = self.font.stringWidth(tempSubString[_x:_width])
        else:
            tempString = self.noSpaces(self.currentText)
            x = self.font.stringWidth(tempString[:self.highlight[0]])
            width = self.font.stringWidth(tempString[self.highlight[0]:self.highlight[1]])
        apply(glColor4f, color_pallet.text_highlight)
        glRectf(self.x + x + 2, self.y + 2, self.x + x + width + 3, self.y + self.yOffset + 1)

    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1, 1, 1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)

        glLineWidth(1)
        glBegin(GL_LINE_STRIP)
        glVertex3f(self.x, self.y, self.z)
        glVertex3f(self.x+self.w, self.y, self.z)
        glVertex3f(self.x+self.w, self.y+self.h, self.z)
        glVertex3f(self.x, self.y+self.h, self.z)
        glVertex3f(self.x, self.y, self.z)
        glEnd()

        if self.formatThisFrame:
            self.formatText()
            self.formatThisFrame = False

        if focus.doIHaveFocus(self):
            self.drawCaret()
            if self.highlight:
                self.drawHighlight()

        if focus.doIHaveFocus(self):
            glColor3f(1, 1, 1)
        else:
            glColor3f(0.75, 0.75, 0.75)
        if self.windowBounds:
            self.font.drawString(self.subText, self.x + self.xOffset, self.y + self.yOffset)
        else:
            self.font.drawString(self.currentText, self.x + self.xOffset, self.y + self.yOffset)

    # def keyPressed(self, key):
    #     if key == 127:
    #         self.currentText = self.currentText[:-1]
    #     elif key < 256:
    #         if self.windowBounds:
    #             if self.windowBounds[1] == len(self.currentText):
    #                 self.windowBounds[0] += 1
    #                 self.windowBounds[1] += 1
    #         self.currentText += chr(key)

    def keyPressed(self, key):
        self.lastEvent = time.time()
        # shift + arrow keys:
        # is there already a highlight?
        # ---- if so, are there window boundaries?
        # ---- ---- if so, is the highlight already at the edge of the bounds?
        # ---- ---- ---- if arrow key takes highlight past boundaries, shift boundaries + add to highlight.
        # ---- if not, proceed normally
        # if not, are there window boundaries?
        # ---- if so, is the caret already at the edge?
        # ---- ---- ---- if so, highlight + shift boundaries
        # ---- if not, proceed normally

        # arrow keys:
        # is there a highlight?
        # ---- if so, highlight = None, caretIndex = either left end or right end of highlight
        # are there window boundaries?
        # ---- if so, is the caret at the edge?
        # ---- ---- if so, shift caret and window bounds

        if key == 356 and glutGetModifiers() == 1: # shift + left arrow
            if self.highlight:
                if self.windowBounds:
                    # if highlight is at left edge of bounds
                    if self.highlight[0] == self.windowBounds[0] and self.highlight[0] > 0:
                        self.highlight[0] -= 1
                        self.caretIndex = self.highlight[0]
                        self.windowBounds[0] -= 1
                        self.formatText("LEFT")
                    # if highlight is past left edge: jump there
                    elif self.highlight[0] < self.windowBounds[0] and self.highlight[0] > 0:
                        self.highlight[0] -= 1
                        self.caretIndex = self.highlight[0]
                        self.windowBounds[0] == self.highlight[0]
                        self.formatText("LEFT")
                    # if highlight is past edge but at end of text: jump but don't add
                    elif self.highlight[0] < self.windowBounds[0] and self.highlight[0] == 0:
                        self.caretIndex = 0
                        self.windowBounds[0] = 0
                        self.formatText("LEFT")
                    # if highlight is safely within bounds
                    elif self.highlight[0] > self.windowBounds[0]:
                        self.highlight[0] -= 1
                        self.caretIndex = self.highlight[0]
                else:
                    if self.highlight[0] > 0:
                        self.highlight[0] -= 1
                        self.caretIndex = self.highlight[0]
                    else:
                        self.caretIndex = self.highlight[0]
            else:
                # if there's a window boundary and NO highlight
                if self.windowBounds:
                    if self.caretIndex == self.windowBounds[0] and self.caretIndex > 0:
                        self.highlight = [self.caretIndex - 1, self.caretIndex]
                        self.caretIndex -= 1
                        self.windowBounds[0] -= 1
                        self.formatText("LEFT")
                    elif self.caretIndex > 0:
                        self.highlight = [self.caretIndex - 1, self.caretIndex]
                        self.caretIndex -= 1
                else:
                    if self.caretIndex > 0:
                        self.highlight = [self.caretIndex - 1, self.caretIndex]
                        self.caretIndex -= 1

        elif key == 358 and glutGetModifiers() == 1: # shift + right arrow
            if self.highlight:
                if self.windowBounds:
                    # if highlight is at right edge of bounds
                    if self.highlight[1] == self.windowBounds[1] and self.highlight[1] < len(self.currentText):
                        self.highlight[1] += 1
                        self.caretIndex = self.highlight[1]
                        self.windowBounds[1] += 1
                        self.formatText("RIGHT")
                    # if highlight is past right edge: jump there
                    elif self.highlight[1] > self.windowBounds[1] and self.highlight[1] < len(self.currentText):
                        self.highlight[1] += 1
                        self.caretIndex = self.highlight[1]
                        self.windowBounds[1] = self.highlight[1]
                        self.formatText("RIGHT")
                    elif self.highlight[1] > self.windowBounds[1] and self.highlight[1] == len(self.currentText):
                        self.caretIndex = self.highlight[1]
                        self.windowBounds[1] = self.highlight[1]
                        self.formatText("RIGHT")
                    elif self.highlight[1] < self.windowBounds[1]:
                        self.highlight[1] += 1
                        self.caretIndex = self.highlight[1]
                else:
                    if self.highlight[1] < len(self.currentText):
                        self.highlight[1] += 1
                        self.caretIndex = self.highlight[1]
                    else:
                        self.caretIndex = self.highlight[1]
            else:
                if self.windowBounds:
                    if self.caretIndex == self.windowBounds[1] and self.caretIndex < len(self.currentText):
                        self.highlight = [self.caretIndex, self.caretIndex + 1]
                        self.caretIndex = self.highlight[1]
                        self.windowBounds[1] += 1
                        self.formatText("RIGHT")
                    elif self.caretIndex < len(self.currentText):
                        self.highlight = [self.caretIndex, self.caretIndex + 1]
                        self.caretIndex += 1
                else:
                    if self.caretIndex < len(self.currentText):
                        self.highlight = [self.caretIndex, self.caretIndex + 1]
                        self.caretIndex += 1

        elif key == 356: # left arrow
            if self.highlight:
                self.caretIndex = self.highlight[0]
                if self.windowBounds:
                    self.windowBounds[0] = self.highlight[0]
                    self.formatText("LEFT")
                self.highlight = None
            elif self.windowBounds:
                if self.caretIndex > 0 and self.caretIndex != self.windowBounds[0]:
                    self.caretIndex -= 1
                elif self.caretIndex == self.windowBounds[0] and self.windowBounds[0] > 0:
                    self.caretIndex -= 1
                    self.windowBounds[0] -= 1
                    self.formatText("LEFT")
            else:
                if self.caretIndex > 0:
                    self.caretIndex -= 1

        elif key == 358: # right arrow
            if self.highlight:
                self.caretIndex = self.highlight[1]
                if self.windowBounds:
                    self.windowBounds[1] = self.highlight[1]
                    self.formatText("RIGHT")
                self.highlight = None
            elif self.windowBounds:
                if self.caretIndex < self.windowBounds[1] and self.caretIndex < len(self.currentText):
                    self.caretIndex += 1
                elif self.caretIndex == self.windowBounds[1] and self.caretIndex < len(self.currentText):
                    self.caretIndex += 1
                    self.windowBounds[1] += 1
                    self.formatText("RIGHT")
            else:
                if self.caretIndex < len(self.currentText):
                    self.caretIndex += 1

        elif key == 13 or key == 27: #return or escape
            if self.doValidation() == 0 or self.shouldValidate == TextEntry.NONE:
                focus.release(self)
                # self.parent.hide()
                self.caretIndex = len(self.currentText)
                return

        elif key == 127:  # backspace
            self.needsValidation = 1
            if self.windowBounds:
                if self.highlight:
                    self.currentText = self.currentText[:self.highlight[0]] + self.currentText[self.highlight[1]:]
                    self.caretIndex = self.highlight[0]
                    self.highlight = None
                    self.formatText("LEFT")
                elif self.caretIndex != 0:
                    if self.caretIndex == len(self.currentText):
                        self.currentText = self.currentText[:-1]
                        self.caretIndex -= 1
                        self.formatText("RIGHT")
                    else:
                        self.currentText = self.currentText[:self.caretIndex - 1] + self.currentText[self.caretIndex:]
                        self.caretIndex -= 1
                        self.formatText("LEFT")
            else:
                if self.highlight:
                    self.currentText = self.currentText[:self.highlight[0]] + self.currentText[self.highlight[1]:]
                    self.caretIndex = self.highlight[0]
                    self.highlight = None
                    self.formatText("LEFT")
                elif self.caretIndex != 0:
                    if self.caretIndex == len(self.currentText):
                        self.currentText = self.currentText[:-1]
                        self.caretIndex -= 1
                        self.formatText("LEFT")
                    else:
                        self.currentText = self.currentText[:self.caretIndex - 1] + self.currentText[self.caretIndex:]
                        self.caretIndex -= 1
                        self.formatText("LEFT")

        # backspace
        # is there a highlight?
        # ---- if so, delete all highlighted characters
        # ---- ---- if there are window boundaries, recalculate them based on LEFT anchor
        # if not:
        # ---- are there window boundaries?
        # ---- ---- if so, delete char and recalculate anchor LEFT
        # ---- if not, delete char normally

        elif key == 13 or key == 27: #return or escape
            if self.doValidation() == 0 or self.shouldValidate == TextEntry.NONE:
                focus.release(self)
                self.parent.hide()
                self.caretIndex = len(self.currentText)
                self.highlight = None

        elif key < 256 and key != 13:
            self.needsValidation = 1
            if self.windowBounds:
                if self.highlight:
                    self.currentText = self.currentText[:self.highlight[0]] + chr(key) + self.currentText[self.highlight[1]:]
                    self.caretIndex = self.highlight[0] + 1
                    self.highlight = None
                    self.formatText("LEFT")
                elif self.windowBounds[1] == len(self.currentText) or self.windowBounds[1] == self.caretIndex:
                    self.currentText = self.currentText[:self.caretIndex] + chr(key) + self.currentText[self.caretIndex:]
                    self.caretIndex += 1
                    self.windowBounds[1] += 1
                    self.formatText("RIGHT")
                else:
                    self.currentText = self.currentText[:self.caretIndex] + chr(key) + self.currentText[self.caretIndex:]
                    self.caretIndex += 1
                    self.formatText("RIGHT")
            else:
                if self.highlight:
                    self.currentText = self.currentText[:self.highlight[0]] + chr(key) + self.currentText[self.highlight[1]:]
                    self.caretIndex = self.highlight[0] + 1
                    self.highlight = None
                    self.formatText("LEFT")
                else:
                    self.currentText = self.currentText[:self.caretIndex] + chr(key) + self.currentText[self.caretIndex:]
                    self.caretIndex += 1
                    self.formatText("RIGHT")

        # if key < 256 and key != ENTER KEY:
        # ---- if window bounds exist:
        # ---- ---- if windowBounds[1] == len(self.currentText) or windowBounds[1] == caretIndex:
        # ---- ---- ---- add key, caret++, windowBounds[1]++
        # ---- ---- ---- recalculate anchor RIGHT (uses new windowBounds location)
        # ---- ---- else recalculate anchor LEFT

        # if escape or return:
        # ---- unfocus, validate

    def handleMouse(self, *args):
        # return 1 if handled, else 0
        if len(args) == 0:
            # mouse was just released
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.mouseState = MouseTweaker.MOUSE_UP
                self.mouseReleased()
                return 1
        if len(args) == 2:
            # moving
            if self.x < args[0] < self.x + self.w and self.y < args[1] < self.y + self.h:
                self.mouseState = MouseState.MOUSE_HOVER
                return 1
            else:
                self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            # mouse is either pressed or dragging.
            # if it has been pressed:
            if self.mouseState == MouseState.MOUSE_HOVER:
                self.mousePressed(args[0], args[1])
                self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                return 1
            elif self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.mouseDrag(args[0], args[1])
                return 1

    def mousePressed(self, x, y):
        self.lastEvent = time.time()
        self.lastMouseEvent = time.time()
        self.askForFocus()
        xPos = x - self.x
        if self.windowBounds:
            sum, returnPosition = 0, len(self.subText)
            tempSubString = self.noSpaces(self.subText)
            for i in range(len(tempSubString)):
                sum = self.font.stringWidth(tempSubString[:i+1])
                if sum > xPos:
                    returnPosition = i
                    break
            self.caretIndex = returnPosition + self.windowBounds[0]
            self.oldCaretIndex = returnPosition + self.windowBounds[0]
        else:
            sum, returnPosition = 0, len(self.currentText)
            tempString = self.noSpaces(self.currentText)
            for i in range(len(tempString)):
                sum = self.font.stringWidth(tempString[:i+1])
                if sum > xPos:
                    returnPosition = i
                    break
            self.caretIndex = returnPosition
            self.oldCaretIndex = returnPosition

    def mouseDrag(self, x, y):
        self.lastEvent = time.time()
        xPos = x - self.x
        if self.windowBounds:
            sum, returnPosition = 0, len(self.subText)
            tempSubString = self.noSpaces(self.subText)
            for i in range(len(tempSubString)):
                sum = self.font.stringWidth(tempSubString[:i+1])
                if sum > xPos:
                    returnPosition = i
                    break
            self.caretIndex = returnPosition + self.windowBounds[0]
        else:
            sum, returnPosition = 0, len(self.currentText)
            tempString = self.noSpaces(self.currentText)
            for i in range(len(tempString)):
                sum = self.font.stringWidth(tempString[:i+1])
                if sum > xPos:
                    returnPosition = i
                    break
            self.caretIndex = returnPosition

        self.highlight = [self.caretIndex, self.oldCaretIndex]
        if self.highlight[0] == self.highlight[1]:
            self.highlight = None
        else:
            self.highlight.sort()

        # after we calculate the actual highlight, check if the mouse goes past the element itself,
        # and if it does, periodically increment the window bounds & the highlight.
        if self.highlight and self.windowBounds:
            if x - self.x > self.w:
                # off to the right
                self.highlight[1] += 1
                self.windowBounds[1] += 1
                self.formatText("RIGHT")
            elif x - self.x < 0:
                # left
                if self.highlight[0] >= 1:
                    self.highlight[0] -= 1
                    self.windowBounds[0] -= 1
                    self.formatText("LEFT")

        # analyze click location using self.subText
        # if location > self.font.stringWidth(self.subText):
        # ---- if dragTime % 3 == 0:
        # ---- ---- shift window boundaries, anchored RIGHT
        # elif location < self.font.stringWidth(self.subText):
        # ---- if dragTime % 3 == 0:
        # ---- ---- shift window boundaries, anchored LEFT

    def mouseReleased(self):
        pass



class LargeTextField(TextEntry):
    
    BORDER_ACTIVE_ONLY = 3
    BORDER_ALWAYS = 1
    
    def __init__(self, parent=None):
        TextEntry.__init__(self, parent)
        self.showBorder = LargeTextField.BORDER_ALWAYS
        self.lineHeight = 20
        self.h = self.lineHeight * 2
        self.maxX = 200
        self.maxY = None
        self.lines = []
    
    def setBorder(self, flag):
        self.showBorder = flag
    
    def keyPressed(self, key):
        TextEntry.keyPressed(self, key)
        if self.maxX == None:
            self.maxX = 10000

        self.justifyLines()
    
    def justifyLines(self, width = None, recurse = 0):
        
        ww = self.font.stringWidth(self.currentText)
        if ww > self.w - 8:
            if ww < self.maxX - 8:
                self.w = ww + 8
            else:
                self.w = self.maxX
        
        if width == None:
            width = self.w
        
        self.lines = []
        words = string.split(self.currentText)
        count = 1
        while len(words):
            if self.font.stringWidth(string.join(words[:count])) > width or count > len(words):
                if count > 1:
                    count -= 1
                self.lines.append(string.join(words[:count]))
                words = words[count:]
                count = 0
            count += 1
        if not recurse:
            if len(self.lines) == 2 and self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1]) > self.font.stringWidth(self.lines[1]):
#                print "message is",self.message
#                print "lines",self.theLines,self.width
#                print "lengths",getLineLength(self.font, self.theLines[0]), getLineLength(self.font, self.theLines[1])
                self.justifyLines(width = (self.w - 0.35 * self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1])), recurse = 1)
#                print "now lines are",self.theLines,self.width
                if len(self.lines) > 2:
                    self.justifyLines(width = self.w - 0.2 * (self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1])), recurse = 1)
#                    print "now lines are",self.theLines,self.width
                    if len(self.lines) > 2:
                        self.justifyLines(recurse = 1)
        try:
            self.maxLineWidth = max(map(lambda l: self.font.stringWidth(l), self.lines))
        except:
            print "measure width failed",self.lines,self.currentText
        self.h = max(1,len(self.lines)) * self.lineHeight
    
    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1,1,1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)
        glLineWidth(1)
        if self.showBorder == LargeTextField.BORDER_ALWAYS or (self.showBorder == LargeTextField.BORDER_ACTIVE_ONLY and focus.doIHaveFocus(self)):
            glBegin(GL_LINE_STRIP)
            glVertex3f(self.x, self.y, self.z)
            glVertex3f(self.x+self.w, self.y, self.z)
            glVertex3f(self.x+self.w, self.y+self.h, self.z)
            glVertex3f(self.x, self.y+self.h, self.z)
            glVertex3f(self.x, self.y, self.z)
            glEnd()
        for n in range(len(self.lines)):
            self.font.drawString(self.lines[n], self.x + 2, self.y + 15 + 20 * n)    
    

class OldComboBox(Button):
    
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.currentChoice = 1
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 22
        self.spacing = self.h
        self.choices = ["no choices","nothing","nada"]
        self.isActive = 0
        self.callback = self.handleClick

        self.selectionCallback = self.defaultCallback
    
    def defaultCallback(self):
        print "SELECTED: ",self.getCurrentChoice()
    
    def setSelectionCallback(self, c):
        self.selectionCallback = c
    
    def maybeCallSelectionCallback(self):
        if self.selectionCallback:
            self.selectionCallback()
    
    def handleClick(self):
        if not self.isActive:
            self.isActive = 1
            return
    
    def getCurrentChoice(self):
        return self.choices[self.currentChoice]
    
    def setCurrentChoice(self, c):
        if c in self.choices:
            self.currentChoice = self.choices.index(c)
    
    def handleMouse(self, *args):
        if self.isActive:
           #print "CB handle mouse",args
           offset = self.currentChoice * self.spacing 
           
           if len(args) == 0:
               handled = 0
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                   if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y - offset and self.lastMouseY < self.y - offset + self.spacing * len(self.choices):
                       offY = self.lastMouseY - self.y
                       #print "offY",offY,self.y, self.lastMouseY
                       offY /= self.spacing

                       #print "offY",offY
                       #print "choice", self.currentChoice
                       self.currentChoice += offY
                       #print "choice2", self.currentChoice
                       #print "choces",self.choices
                       self.isActive = 0
                       self.maybeCallSelectionCallback()
                       handled = 1
               else:
                   self.isActive = 0
               self.mouseState = MouseTweaker.MOUSE_UP
               return handled
           if len(args) == 3:
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                   self.lastMouseX = args[0]
                   self.lastMouseY = args[1]
                   return 1

               if self.mouseState == MouseTweaker.MOUSE_UP:
                   #print "check mouse",
                   if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y - offset and args[1] < self.y - offset + self.spacing * len(self.choices):
                       #print "engaged"
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                       self.lastMouseX = args[0]
                       self.lastMouseY = args[1]
                       self.maybeCallDownCallback()
                       return 1
                   else:
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                       return 0
        else:
            # in order to use Button.handleMouse (as opposed to self.handleMouse),
            # a self reference must be included before the args.
            # make a list with self as the first item...
            a = [self]
            # add args (the mouse coordinates)
            a.extend(args)
            # use apply to run Button.handleMouse with args
            return apply(Button.handleMouse,a)
    
    def setChoices(self, choices):
        self.choices = choices
    
    def draw(self):
        if self.isActive:

            glColor3f(0.5, 0.5, 0.5)
            # offset for box
            offset = self.currentChoice * self.spacing
            self.drawActive(offset)

            glColor3f(1,1,1)
            for n in range(len(self.choices)):
                # self.font.drawString(self.choices[n], self.x + 4, self.y + self.h - 7 - (self.currentChoice - n) * self.spacing)
                self.font.drawString(self.choices[n], self.x + 4, self.y + self.h - 7 - (self.currentChoice - n) * self.spacing)
            glColor3f(0.6, 0.6, 0.6)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 + 1, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()
        else:
            glColor3f(0.5, 0.5, 0.5)
            # drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 4)
            Button.draw(self)
        
            glColor3f(1,1,1)
            self.font.drawString(self.choices[self.currentChoice], self.x + 4, self.y + self.h - 7)
            glColor3f(0.8, 0.8, 0.8)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 + 1, self.z)                
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()

    def drawActive(self, offset):
        # DROP SHADOW!!
        d = 3
        
        glColor4f(0, 0, 0, 0.3)
        glBegin(GL_POLYGON)
        glVertex3f(self.x + d, self.y - offset + d, 0)
        glVertex3f(self.x + self.w + d, self.y - offset + d, 0)
        glColor4f(0, 0, 0, 0.2)
        glVertex3f(self.x + self.w + d, self.y - offset + self.spacing*len(self.choices) + d, 0)
        glVertex3f(self.x + d, self.y - offset + self.spacing*len(self.choices) + d, 0)
        glEnd()

        glBegin(GL_POLYGON)
        apply(glColor3f, self.color)
        glVertex3f(self.x, self.y - offset, 0)
        glVertex3f(self.x + self.w, self.y - offset, 0)
        glColor3f(0.3, 0.3, 0.3)
        glVertex3f(self.x + self.w, self.y - offset + self.spacing*len(self.choices), 0)
        glVertex3f(self.x, self.y - offset + self.spacing*len(self.choices), 0)
        glEnd()



class ComboBox(Button):
    
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.currentChoice = 1
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 22
        self.spacing = self.h
        self.choices = ["no choices","nothing","nada"]
        self.isActive = 0
        self.callback = self.handleClick
        self.highlighted = 0
        self.selectionCallback = self.defaultCallback
    
    def defaultCallback(self):
        # print "SELECTED: ",self.getCurrentChoice()
        pass
    
    def setSelectionCallback(self, c):
        self.selectionCallback = c
    
    def maybeCallSelectionCallback(self):
        if self.selectionCallback:
            self.selectionCallback()
    
    def handleClick(self):
        if not self.isActive:
            self.isActive = 1
            return
    
    def getCurrentChoice(self):
        return self.choices[self.currentChoice]
    
    def setCurrentChoice(self, c):
        if c in self.choices:
            self.currentChoice = self.choices.index(c)
    
    def handleMouse(self, *args):
        if self.isActive:
           #print "CB handle mouse",args
           offset = 0

           # MOUSE MOVED
           if len(args) == 2:
                x, y = args[0], args[1]
                if x > self.x and x < self.x + self.w and y > self.y and y < self.y + self.spacing * len(self.choices):
                    self.highlighted = int((y - self.y) / self.spacing)
           
           # RELEASED
           if len(args) == 0:
               handled = 0
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                   if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.spacing * len(self.choices):
                       
                       offY = self.lastMouseY - self.y
                       offY /= self.spacing
                       # print "curchoice was", self.currentChoice,
                       self.currentChoice = offY
                       # print "and is", self.currentChoice

                       self.isActive = 0
                       self.maybeCallSelectionCallback()
                       handled = 1
               else:
                   self.isActive = 0
               self.mouseState = MouseTweaker.MOUSE_UP
               return handled

            #DRAGGING
           if len(args) == 3:
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                   self.lastMouseX = args[0]
                   self.lastMouseY = args[1]
                   return 1

               if self.mouseState == MouseTweaker.MOUSE_UP:
                   #print "check mouse",
                   if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y - offset and args[1] < self.y - offset + self.spacing * len(self.choices):
                       #print "engaged"
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                       self.lastMouseX = args[0]
                       self.lastMouseY = args[1]
                       self.maybeCallDownCallback()
                       return 1
                   else:
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                       return 0
        else:
            # in order to use Button.handleMouse (as opposed to self.handleMouse),
            # a self reference must be included before the args.
            # make a list with self as the first item...
            a = [self]
            # add args (the mouse coordinates)
            a.extend(args)
            # use apply to run Button.handleMouse with args
            return apply(Button.handleMouse,a)
    
    def setChoices(self, choices):
        self.choices = choices
    
    def draw(self):
        if self.isActive:

            glColor3f(0.5, 0.5, 0.5)
            # offset for box
            offset = 0
            self.drawActive(offset)

            glColor3f(1,1,1)
            for n in range(len(self.choices)):
                if n == self.highlighted:
                    apply(glColor4f, color_pallet.selection_highlight)
                    glRectf(self.x, self.y + n*self.spacing, self.x + self.w, self.y + n*self.spacing + self.spacing)
                    glColor3f(1, 1, 1)
                self.font.drawString(self.choices[n], self.x + 4, self.y + self.h - 7 + (n * self.spacing))

            # up&down arrows
            glColor3f(0.6, 0.6, 0.6)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 + 1, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()
        else:
            glColor3f(0.5, 0.5, 0.5)
            # drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 4)
            Button.draw(self)
        
            glColor3f(1,1,1)
            self.font.drawString(self.choices[self.currentChoice], self.x + 4, self.y + self.h - 7)
            glColor3f(0.8, 0.8, 0.8)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 4, self.y + self.h/2 + 1, self.z)                
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()

    def drawActive(self, offset):
        # DROP SHADOW!!
        d = 3
        
        glColor4f(0, 0, 0, 0.3)
        glBegin(GL_POLYGON)
        glVertex3f(self.x + d, self.y - offset + d, 0)
        glVertex3f(self.x + self.w + d, self.y - offset + d, 0)
        glColor4f(0, 0, 0, 0.2)
        glVertex3f(self.x + self.w + d, self.y - offset + self.spacing*len(self.choices) + d, 0)
        glVertex3f(self.x + d, self.y - offset + self.spacing*len(self.choices) + d, 0)
        glEnd()

        glBegin(GL_POLYGON)
        apply(glColor3f, self.color)
        glVertex3f(self.x, self.y - offset, 0)
        glVertex3f(self.x + self.w, self.y - offset, 0)
        glColor3f(0.3, 0.3, 0.3)
        glVertex3f(self.x + self.w, self.y - offset + self.spacing*len(self.choices), 0)
        glVertex3f(self.x, self.y - offset + self.spacing*len(self.choices), 0)
        glEnd()



class PropertyDrawer(Button):
    def __init__(self):
        Button.__init__(self, None)
        # self.zIndex = 10
        self.x = ofGetWidth()
        self.y = 20
        self.w = 300
        self.h_offset = 100
        self.h = ofGetHeight() - self.h_offset
        self.currentNode = None
        self.children = []
        self.hidden = True
        # easing
        self.ease_coordinates = []
        self.in_transit = False
        self.animate_length = 1.0 # seconds
        self.time = 0
        # button
        self.drawerButton = DrawerButton(self, self.x - 20, self.y)

    def draw(self):
        if self.in_transit == False:
            if self.hidden:
                self.x = ofGetWidth()
                self.h = ofGetHeight() - self.h_offset
            else:
                self.x = ofGetWidth() - self.w
                self.h = ofGetHeight() - self.h_offset
        else:
            self.h = ofGetHeight() - self.h_offset
            t = time.time() - self.time
            if t < self.animate_length:
                self.x = self.ease(t, self.ease_coordinates)
            else:
                self.done_easing()

        self.drawerButton.position(self.x - 20, self.y)
        self.drawerButton.draw()

        if self.hidden:
            return

        apply(glColor3f, color_pallet.property_drawer)
        glRectf(self.x, self.y, self.x + self.w, self.y + self.h)

        glPushMatrix()
        glTranslatef(self.x, self.y, 0)
        for c in self.children:
            c.draw()
        glPopMatrix()

    def handleMouse(self, *args):
        if len(self.children):
            childArgs = []
            if len(args) == 3:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1, args[2]]
            if len(args) == 2:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1]
            # this list is reversed to catch drop-down menus correctly
            # (there is a corresponding reversal in Node.showPropertyWindow() )
            for c in reversed(self.children):
                if apply(c.handleMouse, childArgs):
                    return 1
            if len(args) == 3:
                for c in self.children:
                    if focus.doIHaveFocus(c):
                        focus.release(c)

    def populate(self, n, plist):
        self.currentNode = n
        self.children = plist
        # print "b4",self.children
        # self.children.reverse()
        # print "aftr",self.children
        if self.hidden == True:
            self.open()

    def release(self, n):
        if self.currentNode == n:
            self.currentNode = None
            self.children = []
            self.close()

    def open(self):
        self.opening = True
        self.hidden = False
        self.in_transit = True
        self.ease_coordinates = [self.x, self.x - self.w]
        self.time = time.time()

    def close(self):
        self.opening = False
        self.in_transit = True
        self.ease_coordinates = [self.x, ofGetWidth()]
        self.time = time.time()

    def ease(self, time, coordinates):
        f,t = coordinates
        dist = t-f
        # return (time/self.animate_length) * dist + f
        return -dist * time*(time-2) + f

    def done_easing(self):
        self.in_transit = False
        if self.opening == False:
            self.hidden = True
            self.x = ofGetWidth()
            self.drawerButton.setMode("open")
        else:
            self.drawerButton.setMode("close")



class DrawerButton(Button):
    def __init__(self, parent, x, y):
        Button.__init__(self, None)
        self.parent = parent
        self.x = x
        self.y = y
        self.w = 20
        self.h = 80
        self.callback = self.switchMode
        self.mode = "open"

    def switchMode(self):
        if self.mode == "open":
            self.parent.open()
        else:
            self.parent.close()

    def setMode(self, m):
        self.mode = m

    def draw(self):

        glBegin(GL_POLYGON)

        if self.mouseState == MouseState.MOUSE_HOVER:
            apply(glColor3f, color_pallet.drawer_button_top_hover)
        else:
            apply(glColor3f, color_pallet.drawer_button_top)

        glVertex3f(self.x, self.y + self.h, 0)
        glVertex3f(self.x, self.y, 0)

        if self.mouseState == MouseState.MOUSE_HOVER:
            apply(glColor3f, color_pallet.drawer_button_bottom_hover)
        else:
            apply(glColor3f, color_pallet.drawer_button_bottom)

        glVertex3f(self.x + self.w, self.y, 0)
        glVertex3f(self.x + self.w, self.y + self.h, 0)
        
        glEnd()

        # glColor3f(0, 0, 0)
        # glBegin(GL_LINE_LOOP)
        # glVertex3f(self.x, self.y, 0)
        # glVertex3f(self.x + self.w, self.y, 0)
        # glVertex3f(self.x + self.w, self.y + self.h, 0)
        # glVertex3f(self.x, self.y + self.h, 0)
        # glEnd()

        glPushMatrix()
        # bottom-right corner
        glTranslatef(self.x + self.w, self.y + self.h, 0)
        glRotatef(-90, 0, 0, 1)
        apply(glColor3f, color_pallet.node_box_text)
        self.font.drawString(self.mode, self.h/2 - self.font.stringWidth(self.mode)/2, -5)
        glPopMatrix()

    def position(self, x, y):
        self.x, self.y = x, y


class FocusManager:
    
    def __init__(self):
        global manager
        self.currentFocus = manager
    
    def doIHaveFocus(self, obj):
        return obj == self.currentFocus
    
    def claim(self, obj):
        self.currentFocus = obj
    
    def release(self, obj):
        global manager
        if obj == self.currentFocus:
            self.currentFocus = manager
    
    def keyPressed(self, key):
        # if key == 8:
        #     manager.deleteAllSelected()
        if self.currentFocus:
            #print self.currentFocus, "has stolen keypress"
            self.currentFocus.keyPressed(key)


manager = PSGObjectManager()
focus = FocusManager()
            
