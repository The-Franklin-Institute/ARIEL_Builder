
#Todo

#activate buttons on release, not press?
#draw nicer buttons?
#draw labels on buttons

from OpenGL.GLUT import *
import psl
from psl import *
from psl import drawutils
from psl import fontmanager

cocoadialog = '"'+psl.__path__[0]+"/CocoaDialog.app/Contents/MacOS/CocoaDialog"+'"'

class MouseState:
    
    MOUSE_UP = 2
    MOUSE_DRAGGING_US = 3
    MOUSE_DRAGGING_ELSEWHERE = 4
    MOUSE_HOVER = 5
    
class MouseTweaker:

    MOUSE_UP = 2
    MOUSE_DRAGGING_US = 3
    MOUSE_DRAGGING_ELSEWHERE = 4

    def __init__(self, parent):
        self.radiusSquared = 25
        self.x = 0
        self.y = 0
        self.parent = parent

        self.xCallback = None
        self.yCallback = None

        self.mouseState = MouseTweaker.MOUSE_UP
        self.startx = None
        self.starty = None

    def setXCallback(self, xcb):
        self.xCallback = xcb

    def setYCallback(self, ycb):
        self.yCallback = ycb

    def draw(self):
        glColor3f(1,0,0)
        glRectf(self.x-2,self.y-2,self.x+2,self.y+2)

    def handleMouse(self, *args):
        if len(args) == 0:
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:

                if self.xCallback:
                    val = args[0] - self.startx + self.x
                    self.x = self.xCallback(val)
                    self.startx = args[0]

                if self.yCallback:
                    val = args[1] - self.starty + self.y
                    self.y = self.yCallback(val)
                    self.starty = args[1] 

            if self.mouseState == MouseTweaker.MOUSE_UP:
#                print "check mouse", ofDistSquared(args[0],args[1], self.x + self.parent.x, self.y + self.parent.y)
                if ofDistSquared(args[0],args[1], self.x + self.parent.x, self.y + self.parent.y) < self.radiusSquared:
#                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.startx = args[0]
                    self.starty = args[1]
                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE

def ctrlIsPressed():
    print "MOD",glutGetModifiers()
    return glutGetModifiers() > 0 #& GLUT_ACTIVE_CTRL
                    
class Ruler:

    def __init__(self):
        self.x = 0
        self.y = 0
        self.startx = 0
        self.starty = 0        
        self.mouseState = MouseTweaker.MOUSE_UP

    def handleMouse(self, *args):
#        print "ruler mouse"
        if len(args) == 0:
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 2:
            self.x = args[0]
            self.y = args[1]            
        if len(args) == 3:
            self.x = args[0]
            self.y = args[1]

            if self.mouseState == MouseTweaker.MOUSE_UP:
                self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                self.startx = args[0]
                self.starty = args[1]

    def draw(self):
        glColor3f(0.2, 0.8, 0.2)
        if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
            glBegin(GL_LINES)
            glVertex3f(self.startx, self.starty, 0)
            glVertex3f(self.x, self.y, 0)
            glEnd()
            ofDrawBitmapString("%d, %d" % (self.x - self.startx, self.y - self.starty), self.startx - 20, self.starty - 10)
        glBegin(GL_LINES)
        glVertex3f(self.x - 5, self.y, 0)
        glVertex3f(self.x + 5, self.y, 0)        
        glVertex3f(self.x, self.y - 5, 0)
        glVertex3f(self.x, self.y + 5, 0)        
        glEnd()     
        ofDrawBitmapString("%d, %d" % (self.x, self.y), self.x - 20, self.y - 10)

class SelectionManager:

    def __init__(self):
        self.selectedObjects = []

    def deselectAll(self):
        self.selectedObjects = []

    def select(self, obj):
        if obj not in self.selectedObjects:
            self.selectedObjects.append(obj)

    def deselect(self, obj):
        if obj in self.selectedObjects:
            self.selectedObjects.remove(obj)

    def isSelected(self, obj):
        return obj in self.selectedObjects

    def toggleSelection(self, obj):
        if self.isSelected(obj):
            self.deselect(obj)
        else:
            self.select(obj)

    def notifyMove(self, obj, x, y):
        for o in self.selectedObjects:
            if o == obj:
                continue
            o.shiftPosition(x, y)

class PSGObjectManager:

    def __init__(self):
        self.objects = []
        self.ruler = Ruler()
        self.selectionManager = SelectionManager()
        self.enableTweakingFlag = 0
        self.lastMouseX = 0
        self.lastMouseY = 0

    def getSelectionManager(self):
        return self.selectionManager

    def getMouseLocation(self):
        return self.lastMouseX, self.lastMouseY

    def updateDrawOrder(self):
        self.objects.sort()

    def addObject(self, o):
        if o not in self.objects:
            self.objects.append(o)
            self.updateDrawOrder()

    def enableTweaking(self):
        print "tweaking enabled"
        self.enableTweakingFlag = 1
        for o in self.objects:
            o.enableTweaking = 1

    def disableTweaking(self):
        print "tweaking disabled"
        self.enableTweakingFlag = 0        
        for o in self.objects:
            o.enableTweaking = 0

    def keyPressed(self, key):
        if key == 101:
            self.enableTweaking()
        if key == 100:
            self.disableTweaking()            

    def handleMouse(self, *args):
#        print
#        print "PSG HANDLE ",args
        for n in range(len(self.objects)):
            o = self.objects[-1-n]
#            print "try",o,"index",o.zIndex
            if apply(o.devHandleMouse,args):
#                print "mouse event consumed by",o
                return
        if len(args) >= 2:
            self.lastMouseX = args[0]
            self.lastMouseY = args[1]
        if len(args) in (0,):
            self.selectionManager.deselectAll()
        apply(self.ruler.handleMouse, args)

    def draw(self):
        for o in self.objects:
            if not o.parent:
                o.devDraw()
        if self.enableTweakingFlag:
            self.ruler.draw()

class PSGObject:

    def __init__(self, parent=None):
        self.x = 100
        self.y = 100
        self.w = 100
        self.h = 100
        self.z = 0
        self.zIndex = 0
        self.enableTweaking = 0
        self.parent = parent
        self.children = []

        if not self.parent:
            global manager
            manager.addObject(self)
        else:
            self.parent.children.append(self)

        self.posTweaker = MouseTweaker(self)
        self.posTweaker.setXCallback(self._setX)
        self.posTweaker.setYCallback(self._setY)

        self.widthTweaker = MouseTweaker(self)
        self.widthTweaker.x = self.w
        self.widthTweaker.y = -31
        self.widthTweaker.setXCallback(self._setW)

        self.heightTweaker = MouseTweaker(self)
        self.heightTweaker.x = -31
        self.heightTweaker.y = self.h
        self.heightTweaker.setYCallback(self._setH)

    def __lt__(self, o):
        return self.zIndex < o.zIndex

    def getChildMouseArgs(self, args):
        childArgs = []
        if len(args) == 3:
            cx1 = args[0] - self.x
            cy1 = args[1] - self.y
            childArgs = [cx1, cy1, args[2]]
        if len(args) == 2:
            cx1 = args[0] - self.x
            cy1 = args[1] - self.y
            childArgs = [cx1, cy1]                
        return childArgs

    def shiftPosition(self, x,y):
        self.x += x
        self.y += y

    def getAbsolutePosition(self):
        x,y = 0,0
        if self.parent:
            x,y = self.parent.getAbsolutePosition()
        return self.x + x, self.y + y

    def getPosition(self):
        return self.x, self.y

    def setPosition(self, x, y):
        self.x = x
        self.y = y

    def _setX(self, x):
        self.x += x
        return 0

    def _setY(self, y):
        self.y += y        
        return 0

    def _setW(self, w):
        self.w = w
        return self.w

    def _setH(self, h):
        self.h = h        
        return self.h    
    
    def devDraw(self):
        self.draw()
        if self.enableTweaking:
            self.drawLayout()

    def draw(self):
        ofEnableAlphaBlending()
        glColor4f(1,0,0,0.3)
        glRectf(self.x,self.y, self.x + self.w, self.y + self.h)
        ofDisableAlphaBlending()
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z)
        for c in self.children:
            c.draw()
        glPopMatrix()

    def handleMouse(self, *args):
        pass

    def devHandleMouse(self, *args):
        if self.enableTweaking:
            self.handleMouseLayout(args)
        else:
            return apply(self.handleMouse, args)

    def handleMouseLayout(self, args):
        print "HML",args
        apply(self.posTweaker.handleMouse, args)
        apply(self.widthTweaker.handleMouse, args)
        apply(self.heightTweaker.handleMouse, args)
        
    def drawLayout(self):
        glPushMatrix()
        glTranslatef(self.x, self.y, 0)
        glColor3f(1,1,1)
        str = "x: %d, y: %d" % (self.x, self.y)
        ofDrawBitmapString(str, -20,20)
        glBegin(GL_LINES)

        glVertex3f(0, -29, 0)
        glVertex3f(0, -32, 0)
        glVertex3f(self.w, -29, 0)
        glVertex3f(self.w, -32, 0)
        glVertex3f(0, -31, 0)
        glVertex3f(self.w, -31, 0)

        glVertex3f(-29, 0, 0)
        glVertex3f(-32, 0, 0)
        glVertex3f(-29, self.h, 0)
        glVertex3f(-32, self.h, 0)
        glVertex3f(-31, 0, 0)
        glVertex3f(-31, self.h, 0)

        glEnd()

        str = "w: %d" % (self.w)
        ofDrawBitmapString(str, self.w/2-20,-20)

        str = "h: %d" % (self.h)
        ofDrawBitmapString(str, -20,self.h/2-10)

        self.posTweaker.draw()
        self.widthTweaker.draw()
        self.heightTweaker.draw()
        
        glPopMatrix()

class Label(PSGObject):

    def __init__(self, parent=None):
        PSGObject.__init__(self, parent)
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.message = ""
        self.theLines = None
        self.lineSpacing = 21
        self.color = (1,1,1)

    def setColor(self, c):
        self.color = c

    def setLineSpacing(self, s):
        self.lineSpacing = s

    def _setW(self, w):
        self.w = w
        self.theLines = None
        return self.w

    def setMessage(self, str):
        self.message = str
        self.initLines()

    def initLines(self, width = None, recurse = 0):
        if width == None:
            width = self.w
#        print "init lines recurse WIDTH:",width
        self.theLines = []
        words = string.split(self.message)
        count = 1
        while len(words):
            if self.font.stringWidth(string.join(words[:count])) > width or count > len(words):
                if count > 1:
                    count -= 1
                self.theLines.append(string.join(words[:count]))
                words = words[count:]
                count = 0
            count += 1
        if not recurse:
            if len(self.theLines) == 2 and self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1]) > self.font.stringWidth(self.theLines[1]):
                self.initLines(width = self.w - 0.35 * (self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1])), recurse = 1)
                if len(self.theLines) > 2:
                    self.initLines(width = self.w - 0.2 * (self.font.stringWidth(self.theLines[0]) - self.font.stringWidth(self.theLines[1])), recurse = 1)
                    if len(self.theLines) > 2:
                        self.initLines(recurse = 1)
        try:
            self.maxLineWidth = max(map(lambda l: self.font.stringWidth(l), self.theLines))
        except:
            print "measure width failed",self.theLines,self.message
        
    def draw(self,opacity = 1):
        if not self.theLines:
            self.initLines()
        glPushMatrix()
        glTranslatef(self.x, self.y + self.lineSpacing, 0)
        apply(glColor3f,self.color)
        for l in self.theLines:
            glPushMatrix()            
            self.font.drawString(l,0,0)
            glPopMatrix()
            glTranslatef(0, self.lineSpacing, 0)
        glPopMatrix()           
        

class Button(PSGObject):

    def __init__(self, parent=None):
        PSGObject.__init__(self, parent)
        self.label = None
        self.image = None
        self.fontSize = 11
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",self.fontSize)
        self.callback = None
        self.downCallback = None
        self.hoverCallback = None
        self.endHoverCallback = None
        self.mouseState = 0
        self.lastMouseX = 0
        self.lastMouseY = 0
        self.color = (0.3,0.3,0.3)
        self.showLabel = 0
        self.labelWidth = 0
        self.setLabel("")

    def autoSize(self):
        self.w = self.labelWidth + 10
        self.h = self.fontSize + 10

    def setLabel(self, l):
        self.label = l
        self.labelWidth = self.font.stringWidth(l)

    def setColor(self, c):
        self.color = c

    def maybeCallDownCallback(self):
        if self.downCallback:
            self.downCallback()
        else:
            print "no DOWN callback for button with label",self.label

    def maybeCallHoverCallback(self):
        if self.hoverCallback:
            self.hoverCallback()

    def maybeCallEndHoverCallback(self):
        if self.endHoverCallback:
            self.endHoverCallback()

    def maybeCallCallback(self):
        if self.callback:
            self.callback()
        else:
            print "no callback for button with label",self.label

    def handleMouse(self, *args):
        # return 1 if we handled it, 0 otherwise
#        print "button handle mouse",self,args,self.mouseState,self.x, self.y,self.w,self.h
        if len(args) == 0:
            handled = 0
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                 if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
#                     print "do callback"
                     self.maybeCallCallback()
                 handled = 1
            self.mouseState = MouseTweaker.MOUSE_UP
            return handled

        if len(args) == 2:
            if self.mouseState == MouseTweaker.MOUSE_UP:
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
#                    print "hover begin",self
                    self.mouseState = MouseState.MOUSE_HOVER
                    self.maybeCallHoverCallback()
#                    print self,"mouse",self.mouseState
                    return 1

            if self.mouseState == MouseState.MOUSE_HOVER:
                if not (args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h):
#                    print "hover end"
                    self.mouseState = MouseTweaker.MOUSE_UP
                    self.maybeCallEndHoverCallback()
                    return 1
        
        if len(args) == 3:
#            print "mouse state", self.mouseState
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
                if not (self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h):
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0
                return 1

            if self.mouseState in (MouseTweaker.MOUSE_UP, MouseState.MOUSE_HOVER) :
#                print "check mouse", args[0] > self.x, args[0] < self.x + self.w, args[1] > self.y, args[1] < self.y + self.h
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
#                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0

    def draw(self):
        if self.mouseState ==  MouseTweaker.MOUSE_DRAGGING_US:
            glColor3f(0.5,0.5,0.5)
        else:
            apply(glColor3f, self.color)
        drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 4)
        if self.label and self.showLabel:
            glColor3f(1,1,1)
            self.font.drawString(self.label, self.x + self.w/2 - self.labelWidth/2, self.y + self.h/2 + 2)
        if self.image:
            self.image.draw(self.x, self.y)

def getFilenameToOpen():
    import popen2
    out,junk = popen2.popen2(cocoadialog + " fileselect")
    return out.readline()[:-1]

def doPopupMessage(msg,alt=""):
    import popen2
    if alt == "":
        out,junk = popen2.popen2(cocoadialog + ' ok-msgbox --no-cancel --float --text "'+msg+'"')
    else:
        out,junk = popen2.popen2(cocoadialog + ' ok-msgbox --no-cancel --float --text "'+msg+'" --informative-text "'+alt+'"')
    return out.readline()[:-1]

def getFilenameToSave():
    import popen2
    out,junk = popen2.popen2(cocoadialog + " filesave")
    return out.readline()[:-1]
    

class MenuBar(Button):

    #This is not really done

    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.setPosition(0,0)
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.items = []
        self.currentActiveMenu = None
        self.downCallback = self.maybeActivateMenu
        self.widthPerItem = 60
        self.zIndex = 2
        self.h = 20

    def maybeActivateMenu(self):
#        print "maybe activate"
        for i in self.items:
#            print "check",i
            if self.lastMouseX > i.x and self.lastMouseX < i.x + self.widthPerItem:
#                print "activate!!"
                i.activate()
                if self.currentActiveMenu and self.currentActiveMenu != i:
#                    print "deactivate"
                    self.currentActiveMenu.deactivate()
                self.currentActiveMenu = i
#        print "curretn active",self.currentActiveMenu

    def addItem(self, i):
        self.items.append(i)
        i.parent = self
        for n in range(len(self.items)):
            self.items[n].x = 15 + self.widthPerItem * n
        self.w = 15 + self.widthPerItem * (len(self.items) + 1)

    def handleMouse(self, *args):
        # return 1 if we handled it, 0 otherwise
#        print "menubar handle mouse"

        if len(args) == 0:
            handled = 0
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
#                print "RELEASE"
                if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
                     if self.currentActiveMenu:
                         self.currentActiveMenu.deactivate()
                         self.currentActiveMenu = None
                else:
                     if self.currentActiveMenu:
#                         print "active handle!"
                         apply(self.currentActiveMenu.handleMouse, self.getChildMouseArgs(args))
                         self.currentActiveMenu.deactivate()
                         self.currentActiveMenu = None
                handled = 1
            self.mouseState = MouseTweaker.MOUSE_UP
            return handled
        if len(args) == 3:
#            print "3 args"
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
#                print "dragging us",self.currentActiveMenu
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
#                print "pre", self.lastMouseX,  self.x, self.x + self.w, self.lastMouseY, self.y, self.y + self.h
                if not ((self.lastMouseX > self.x) and (self.lastMouseX < (self.x + self.w)) and (self.lastMouseY > self.y) and (self.lastMouseY < (self.y + self.h))):
#                    print "BRANCH"
                    if self.currentActiveMenu:
#                        print "active menu"
                        apply(self.currentActiveMenu.handleMouse, self.getChildMouseArgs(args))
#                        print "back from active menu"
                    return 0
                self.maybeActivateMenu()
                return 1

            if self.mouseState == MouseTweaker.MOUSE_UP:
#                print "check mouse", 
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
#                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                    return 0

    def draw(self):
        glColor3f(0,0,0)
        glRectf(0,0,ofGetScreenWidth(),20)
        for i in self.items:
            i.draw()

class MenuItem(PSGObject):

    def __init__(self, name, parent=None):
        PSGObject.__init__(self, parent)
        self.setPosition(0,0)
        self.name = name
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.children = []
        self.isActive = 0
        self.w = 100
        self.choiceHeight = 20
        self.headerWidth = self.font.stringWidth(self.name) + 20
        self.currentSelection = None

    def activate(self):
        self.isActive = 1

    def deactivate(self):
        self.isActive = 0

    def addItem(self, i):
        self.children.append(i)
        i.parent = self
        for n in range(len(self.children)):
            self.children[n].y = self.choiceHeight + self.choiceHeight * n

    def handleMouse(self, *args):
        if self.isActive:
            if len(args) == 2 or len(args) == 3:
                if args[0] > self.x and args[0] < self.x + self.w:
                    index = (args[1] - self.y) / self.choiceHeight - 1
                    if index < len(self.children) and index >= 0:
                        self.children[index].activate()
                        if self.currentSelection and self.currentSelection != self.children[index]:
                            self.currentSelection.deactivate()
                        self.currentSelection = self.children[index]
            if len(args) == 0:
                for c in self.children:
                    if c.isActive:
                        c.maybeCallCallback()
                        c.deactivate()
                self.deactivate()

    def draw(self):
        glPushMatrix()
        glColor3f(0.8, 0.8, 0.8)
        glTranslatef(self.x, self.y, 0)
        if self.isActive:
            glColor3f(0.2, 0.2, 0.2)
            glRectf(0,self.choiceHeight,self.w,self.choiceHeight+self.choiceHeight*len(self.children))
            glRectf(0,0,self.font.stringWidth(self.name)+5,self.choiceHeight)
            for c in self.children:
                c.draw()
            
        self.font.drawString(self.name, 0, self.choiceHeight-5)
        glPopMatrix()

class MenuEntry(PSGObject):

    def __init__(self, name, callback, parent=None):
        PSGObject.__init__(self, parent)
        self.setPosition(0,0)
        self.name = name
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.isActive = 0
        self.w = 100
        self.h = 20
        self.callback = callback
        
    def maybeCallCallback(self):
#        print "selected menu entry",self.name
        if self.callback:
            self.callback()

    def activate(self):
        self.isActive = 1

    def deactivate(self):
        self.isActive = 0

    def draw(self):
        glPushMatrix()
        glTranslatef(self.x, self.y, 0)
        if self.isActive:
            glColor3f(0.6,0.3,0.3)
            glRectf(0, 0, self.w, self.h)
        glColor3f(0.8, 0.8, 0.8)
        self.font.drawString(self.name, 10, 15)
        glPopMatrix()      

class UndoManager:

    def __init__(self):
        self.maxSteps = 20
        self.undoState = []
        self.redoState = []
        self.storeCallback = None

    def checkpoint(self):
        if self.storeCallback:
            self.storeCallback()

    def setStoreCallback(self, c):
        self.storeCallback = c

    def store(self, state):
        
        if len(self.undoState) and state == self.undoState[-1]:
            print "no change, no undo checkpoint."
            return
        print "ADD UNDO STATE"

        self.undoState.append(state)
        while len(self.undoState) > self.maxSteps:
            del(self.undoState[0])

    def canUndo(self):
        return len(self.undoState) > 0

    def canRedo(self):
        return len(self.redoState) > 0
    
    def undo(self):
        print "GET UNDO STATE"
        if not self.canUndo():
            return None
        self.checkpoint()
        forRedo = self.undoState[-1]
        del(self.undoState[-1])
        state = self.undoState[-1]
        self.redoState.append(forRedo)
        del(self.undoState[-1])
        return state

    def redo(self):
        print "GET REDO STATE"        
        if not self.canRedo():
            return None
        self.checkpoint()
        state = self.redoState[-1]
        del(self.redoState[-1])
        return state

undo = UndoManager()
        
class Window(Button):
    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.label = "to be named"
        self.visible = 0
        self.zIndex = 0.5

    def show(self):
        self.visible = 1

    def validate(self):
        for c in self.children:
            if c.__class__ == TextEntry:
                if c.needsValidation:
                    if c.doValidation():
                        return 1

    def hide(self):
        if not self.validate():
            self.visible = 0

    def addInput(self, i):
        self.inputs.append(i)
        self.doConnectionLayout()

    def addOutput(self, o):
        self.outputs.append(o)
        self.doConnectionLayout()

    def doConnectionLayout(self):
        for i in self.inputs:
            i.setPosition(0,-7)
        for o in self.outputs:
            o.setPosition(0,self.h/2)            

    def handleMouse(self, *args):

        if not self.visible:
            return

        if len(self.children):
            childArgs = []
            if len(args) == 3:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1, args[2]]
            if len(args) == 2:
                cx1 = args[0] - self.x
                cy1 = args[1] - self.y
                childArgs = [cx1, cy1]                
            for c in self.children:
                if apply(c.handleMouse, childArgs):
                    return 1
            

        if len(args) == 0:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                 if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y and self.lastMouseY < self.y + self.h:
                     self.maybeCallCallback()
            self.mouseState = MouseTweaker.MOUSE_UP
        if len(args) == 3:
            if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                if self.lastMouseX or self.lastMouseY:
                    self.x += args[0] - self.lastMouseX
                    self.y += args[1] - self.lastMouseY
                self.lastMouseX = args[0]
                self.lastMouseY = args[1]
                return 1

            if self.mouseState == MouseTweaker.MOUSE_UP:
                print "check mouse", 
                if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y and args[1] < self.y + self.h:
                    print "engaged"
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                    self.lastMouseX = args[0]
                    self.lastMouseY = args[1]
                    self.maybeCallDownCallback()
                    return 1

                else:
                    self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE

    def draw(self):

        if not self.visible:
            return
        
        if self.mouseState ==  MouseTweaker.MOUSE_DRAGGING_US:
            glColor3f(0.5,0.5,0.5)
        else:
            glColor3f(0.3,0.3,0.3)            
        drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 5)
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z)
        for c in self.children:
            c.draw()
        glPopMatrix()

class TextEntry(Button):

    NONE = 0
    NUMBER = 1

    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.callback = self.askForFocus
        self.currentText = ""
        self.shortenDict = {}
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 20
        self.shouldValidate = TextEntry.NONE
        self.needsValidation = 0

    def setValidate(self, f):
        self.shouldValidate = f

    def validateAsNumber(self):
        self.setValidate(TextEntry.NUMBER)

    def doValidation(self):
        status = 1
        if len(self.currentText) and self.shouldValidate == TextEntry.NUMBER:
            try:
                string.atof(self.currentText)
                status = 0
            except:
                doPopupMessage("Please enter a number.","The text '"+self.currentText+"' does not seem to be a number.")
                self.currentText = "0"
                
        self.needsValidation = 0
        self.askForFocus()
        return status

    def askForFocus(self):
        global focus
        focus.claim(self)

    def getShortVersion(self, text):
        if self.shortenDict.has_key(text):
            return self.shortenDict[text]
        else: 
            if self.font.stringWidth(text) < (self.w - 10):
                self.shortenDict[text] = text
                return self.shortenDict[text]
            start = 0
            while self.font.stringWidth("..."+text[start:]) > (self.w - 10):
                start += 1
            self.shortenDict[text] = "..."+text[start:]
            return self.shortenDict[text]
        
    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1,1,1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)
        glLineWidth(1)
        glBegin(GL_LINE_STRIP)
        glVertex3f(self.x, self.y, self.z)
        glVertex3f(self.x+self.w, self.y, self.z)
        glVertex3f(self.x+self.w, self.y+self.h, self.z)
        glVertex3f(self.x, self.y+self.h, self.z)
        glVertex3f(self.x, self.y, self.z)
        glEnd()
        self.font.drawString(self.getShortVersion(self.currentText), self.x + 2, self.y + self.h - 5)

    def keyPressed(self, key):
        print "TExt KEY",key
        if key == 127: #backspace
            self.currentText = self.currentText[:-1]
            self.needsValidation = 1
            return
        if key == 13: #return
            focus.release(self)
            return
        self.currentText += chr(key)
        self.needsValidation = 1        

class LargeTextField(TextEntry):

    BORDER_ACTIVE_ONLY = 3
    BORDER_ALWAYS = 1

    def __init__(self, parent=None):
        TextEntry.__init__(self, parent)
        self.showBorder = LargeTextField.BORDER_ALWAYS
        self.lineHeight = 20
        self.h = self.lineHeight * 2
        self.maxX = 200
        self.maxY = None
        self.lines = []

    def setBorder(self, flag):
        self.showBorder = flag

    def keyPressed(self, key):
        TextEntry.keyPressed(self, key)
        if self.maxX == None:
            self.maxX = 10000

        self.justifyLines()

    def justifyLines(self, width = None, recurse = 0):

        ww = self.font.stringWidth(self.currentText)
        if ww > self.w - 8:
            if ww < self.maxX - 8:
                self.w = ww + 8
            else:
                self.w = self.maxX

        if width == None:
            width = self.w

        self.lines = []
        words = string.split(self.currentText)
        count = 1
        while len(words):
            if self.font.stringWidth(string.join(words[:count])) > width or count > len(words):
                if count > 1:
                    count -= 1
                self.lines.append(string.join(words[:count]))
                words = words[count:]
                count = 0
            count += 1
        if not recurse:
            if len(self.lines) == 2 and self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1]) > self.font.stringWidth(self.lines[1]):
#                print "message is",self.message
#                print "lines",self.theLines,self.width
#                print "lengths",getLineLength(self.font, self.theLines[0]), getLineLength(self.font, self.theLines[1])
                self.justifyLines(width = (self.w - 0.35 * self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1])), recurse = 1)
#                print "now lines are",self.theLines,self.width
                if len(self.lines) > 2:
                    self.justifyLines(width = self.w - 0.2 * (self.font.stringWidth(self.lines[0]) - self.font.stringWidth(self.lines[1])), recurse = 1)
#                    print "now lines are",self.theLines,self.width
                    if len(self.lines) > 2:
                        self.justifyLines(recurse = 1)
        try:
            self.maxLineWidth = max(map(lambda l: self.font.stringWidth(l), self.lines))
        except:
            print "measure width failed",self.lines,self.currentText
        self.h = max(1,len(self.lines)) * self.lineHeight
            

    def draw(self):
        global focus
        if focus.doIHaveFocus(self):
            glColor3f(1,1,1)
        else:
            if self.needsValidation:
                self.doValidation()
            glColor3f(0.75, 0.75, 0.75)
        glLineWidth(1)
        if self.showBorder == LargeTextField.BORDER_ALWAYS or (self.showBorder == LargeTextField.BORDER_ACTIVE_ONLY and focus.doIHaveFocus(self)):
            glBegin(GL_LINE_STRIP)
            glVertex3f(self.x, self.y, self.z)
            glVertex3f(self.x+self.w, self.y, self.z)
            glVertex3f(self.x+self.w, self.y+self.h, self.z)
            glVertex3f(self.x, self.y+self.h, self.z)
            glVertex3f(self.x, self.y, self.z)
            glEnd()
        for n in range(len(self.lines)):
            self.font.drawString(self.lines[n], self.x + 2, self.y + 15 + 20 * n)    


class ComboBox(Button):

    def __init__(self, parent=None):
        Button.__init__(self, parent)
        self.currentChoice = 1
        self.font = fontmanager.manager.getFont("Frutiger-Roman.ttf",11)
        self.h = 22
        self.spacing = self.h
        self.choices = ["no choices","nothing","nada"]
        self.isActive = 0
        self.callback = self.handleClick

        self.selectionCallback = self.defaultCallback

    def defaultCallback(self):
        print "SELECTED: ",self.getCurrentChoice()

    def setSelectionCallback(self, c):
        self.selectionCallback = c

    def maybeCallSelectionCallback(self):
        if self.selectionCallback:
            self.selectionCallback()

    def handleClick(self):
        if not self.isActive:
            self.isActive = 1
            return

    def getCurrentChoice(self):
        return self.choices[self.currentChoice]

    def setCurrentChoice(self, c):
        if c in self.choices:
            self.currentChoice = self.choices.index(c)

    def handleMouse(self, *args):
        if self.isActive:
           print "CB handle mouse",args
           offset = self.currentChoice * self.spacing 
           
           if len(args) == 0:
               handled = 0
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:            
                   if self.lastMouseX > self.x and self.lastMouseX < self.x + self.w and self.lastMouseY > self.y - offset and self.lastMouseY < self.y - offset + self.spacing * len(self.choices):
                       offY = self.lastMouseY - self.y
                       print "offY",offY,self.y, self.lastMouseY
                       offY /= self.spacing

                       print "offY",offY
                       print "choice", self.currentChoice
                       self.currentChoice += offY
                       print "choice2", self.currentChoice
                       print "choces",self.choices
                       self.isActive = 0
                       self.maybeCallSelectionCallback()
                       handled = 1
               else:
                   self.isActive = 0
               self.mouseState = MouseTweaker.MOUSE_UP
               return handled
           if len(args) == 3:
               if self.mouseState == MouseTweaker.MOUSE_DRAGGING_US:
                   self.lastMouseX = args[0]
                   self.lastMouseY = args[1]
                   return 1

               if self.mouseState == MouseTweaker.MOUSE_UP:
                   print "check mouse",
                   if args[0] > self.x and args[0] < self.x + self.w and args[1] > self.y - offset and args[1] < self.y - offset + self.spacing * len(self.choices):
                       print "engaged"
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_US
                       self.lastMouseX = args[0]
                       self.lastMouseY = args[1]
                       self.maybeCallDownCallback()
                       return 1
                   else:
                       self.mouseState = MouseTweaker.MOUSE_DRAGGING_ELSEWHERE
                       return 0
        else:
            a = [self]
            a.extend(args)
            return apply(Button.handleMouse,a)
        
    def setChoices(self, choices):
        self.choices = choices

    def draw(self):
        if self.isActive:
            glColor3f(0.3, 0.3, 0.3)
            offset = self.currentChoice * self.spacing 
            drawutils.drawRoundRectangle(self.x, self.y - offset, self.x + self.w, self.y - offset + self.spacing * len(self.choices), 4)
            glColor3f(1,1,1)
            for n in range(len(self.choices)):
                self.font.drawString(self.choices[n], self.x + 4, self.y + self.h - 8 - (self.currentChoice - n) * self.spacing)
            glColor3f(0.6, 0.6, 0.6)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 7, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 7, self.y + self.h/2 + 1, self.z)                
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()            
        else:
            glColor3f(0.5, 0.5, 0.5)
            drawutils.drawRoundRectangle(self.x, self.y, self.x + self.w, self.y + self.h, 4)
        
            glColor3f(1,1,1)
            self.font.drawString(self.choices[self.currentChoice], self.x + 4, self.y + self.h - 8)
            glColor3f(0.8, 0.8, 0.8)
            glBegin(GL_TRIANGLES)
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 - 5, self.z)
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 - 5 + 4, self.z)
            glVertex3f(self.x + self.w - 10 + 7, self.y + self.h/2 - 5 + 4, self.z)
            
            glVertex3f(self.x + self.w - 10, self.y + self.h/2 + 5, self.z)
            glVertex3f(self.x + self.w - 10 + 7, self.y + self.h/2 + 1, self.z)                
            glVertex3f(self.x + self.w - 10 - 4, self.y + self.h/2 + 1, self.z)
            glEnd()
        

class FocusManager:

    def __init__(self):
        global manager
        self.currentFocus = manager

    def doIHaveFocus(self, obj):
        return obj == self.currentFocus

    def claim(self, obj):
        self.currentFocus = obj

    def release(self, obj):
        global manager
        if obj == self.currentFocus:
            self.currentFocus = manager

    def keyPressed(self, key):
        if self.currentFocus:
            self.currentFocus.keyPressed(key)
        
    
manager = PSGObjectManager()
focus = FocusManager()
            
