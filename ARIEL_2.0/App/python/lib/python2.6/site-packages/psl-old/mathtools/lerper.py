
import time

class ManualLerp:
    def __init__(self, f, t):
        self.frm = f
        self.to = t

    def lerp(self,val):
        d = self.to - self.frm
        return self.frm + d*val

class Lerper:

    def __init__(self, f, t, l,delay=0.0):
        self.startTime = time.time()+delay
        self.frm = f
        self.to = t
        self.length = l
        if self.length == 0:
            self.length = 0.000001
	self.done = 0
        self.completionCallback = None
        self.isComplete = self.isDone

    def getGoal(self):
        return self.to

    def isDone(self):
	if not self.done:
	    self.compute()
	return self.done

    def setCompletionCallback(self, func):
        self.completionCallback = func
    
    def compute(self):
        if time.time() < self.startTime:
            return self.frm
        progress = (time.time() - self.startTime) / self.length
        if progress > 1:
            if self.completionCallback:
                self.completionCallback()
	    self.done = 1
            return self.to
        return self.to * progress + self.frm * (1.0 - progress)

class SwitchLerper:

    def __init__(self, f, t, l):
	self.start = f
	self.end = t
	self.time = l
	self.lerper = Lerper(f,t,l)
        self.completionCallback = None

    def compute(self):
	return self.lerper.compute()
#        print "lerp",v

    def setCompletionCallback(self, func):
        self.completionCallback = func
        self.lerper.completionCallback = func

    def setState(self,val):
#        print "set state", val
	if not val == self.lerper.getGoal():
#            print "NEW LERP"
	    self.lerper = Lerper(self.lerper.compute(),val,self.time)
            self.lerper.setCompletionCallback(self.completionCallback)
#	else:
#	    if not self.start == self.lerper.getGoal():
#		self.lerper = Lerper(self.lerper.compute(),self.start,self.time)

lerps = {}

def newLerp(name, frm, to, length):
    lerps[name] = Lerper(frm, to, length)

def getLerp(name):
    return lerps[name].compute()
            
