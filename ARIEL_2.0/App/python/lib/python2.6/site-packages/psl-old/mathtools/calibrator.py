import cPickle
import matfunc
import sensetable.utils.graphics.geom as geom

class MSACalibration:

    def __init__(self, readingsFile=None):
        self.msaReadings = []
        self.zowieReadings = []
        self.matrix = None
        self.flipMode = None
        if readingsFile:
            data = cPickle.load(readingsFile)
            print "calibration data",data
            assert len(data) == 3
            for d in data:
                self.storeReading(d[0], d[1], d[2], d[3])
            self.compute()

    def setFlipMode(self, f):
        self.flipMode = f

    def storeReading(self,zowieX, zowieY, msaX, msaY):
        self.msaReadings.append((msaX, msaY))
        self.zowieReadings.append((zowieX, zowieY))

    def translate(self,x,y=None):
        print "tx in:",x,y
        if y == None:
            y = x[1]
            x = x[0]

        if not self.matrix:
            print "NO MATRIX"
            return 0,0

        #print matfunc.Matrix([[x],[y],[1]])
            
        v = self.matrix.mmul(matfunc.Matrix([[x],[y],[1]]))

        #print v

        if self.flipMode:
            print "tx out",v[0][0],768 - v[1][0]
            return v[0][0],768 - v[1][0]
        else:
            print "tx out",v[0][0],v[1][0]
            return v[0][0],v[1][0]

    def compute(self):
        if len(self.msaReadings) != 3:
            print "Hmm, I have the wrong number of calibration readings:",len(self.msaReadings)
        z = self.zowieReadings
        m = self.msaReadings
        msa = matfunc.Square([[m[0][0],m[1][0],m[2][0]],[m[0][1],m[1][1],m[2][1]],[1,1,1]])
        zowie = matfunc.Square([[z[0][0],z[1][0],z[2][0]],[z[0][1],z[1][1],z[2][1]],[1,1,1]])

        #print "msa",msa
        #print "zowie",zowie
        #print "zowie inv",zowie.inverse()
        
        self.matrix = msa.mmul(zowie.inverse())

        #print "result",self.matrix


class MultiCal:

    #Handles a bunch of calibration readings over a large space.

    def __init__(self, fname):
        readings = cPickle.load(fname)
        points = {}
        xdivs = set()
        ydivs = set()

        reverseMapX = {}
        reverseMapY = {}
        for r in readings:
            if not reverseMapX.has_key(r[2]):
                reverseMapX[r[2]] = []
            reverseMapX[r[2]].append(r[0])

            if not reverseMapY.has_key(r[3]):
                reverseMapY[r[3]] = []
            reverseMapY[r[3]].append(r[1])

        for k in reverseMapX.keys():
            reverseMapX[k] = sum(reverseMapX[k]) / float(len(reverseMapX[k]))
        for k in reverseMapY.keys():
            reverseMapY[k] = sum(reverseMapY[k]) / float(len(reverseMapY[k]))
        xdivs = reverseMapX.values()
        xdivs.sort()
        ydivs = reverseMapY.values()
        ydivs.sort()        

        def getBestKey(x,y):
            bestX = xdivs[0]
            bestDistance = 10000
            for val in xdivs:
                if abs(x - val) < bestDistance:
                    bestX = val
                    bestDistance = abs(x - val)

            bestY = ydivs[0]
            bestDistance = 10000
            for val in ydivs:
                if abs(y - val) < bestDistance:
                    bestY = val
                    bestDistance = abs(y - val)                    

            return bestX, bestY
            
        for r in readings:
            
            points[getBestKey(r[0],r[1])] = (r[0],r[1],r[2],r[3])

        self.calibrations = {}
        for x in range(len(xdivs)-1):
            for y in range(len(ydivs)-1):
                cal1 = MSACalibration()
                apply(cal1.storeReading, points[(xdivs[x],ydivs[y])])
                apply(cal1.storeReading, points[(xdivs[x+1],ydivs[y])])
                apply(cal1.storeReading, points[(xdivs[x],ydivs[y+1])])
                cal1.compute()
                
                cal2 = MSACalibration()
                apply(cal2.storeReading, points[(xdivs[x+1],ydivs[y+1])])
                apply(cal2.storeReading, points[(xdivs[x+1],ydivs[y])])
                apply(cal2.storeReading, points[(xdivs[x],ydivs[y+1])])
                cal2.compute()

                self.calibrations[(xdivs[x],ydivs[y])] = (cal1,cal2)
        self.xdivs = xdivs
        self.ydivs = ydivs

    def translate(self, x1, y1):
        #First, find which translator to use
        gridx = self.xdivs[-2]
        gridy = self.ydivs[-2]
        nextx = self.xdivs[-1]
        nexty = self.ydivs[-1]

        for x in range(len(self.xdivs)-1):
            if self.xdivs[x] > x1:
                gridx = self.xdivs[max(0,x-1)]
                nextx = self.xdivs[x]
                break
            
        for y in range(len(self.ydivs)-1):                
            if self.ydivs[y] > y1:
                gridy = self.ydivs[max(0,y-1)]
                nexty = self.ydivs[y]
                break

        #Okey, now we have selected a rectangle
        #which is divided into two triangles
        #which of those do we want?
        cal = None
        if geom.getDistance((x1,y1),(gridx,gridy)) < geom.getDistance((x1,y1),(nextx,nexty)):
            cal = self.calibrations[(gridx,gridy)][0]
        else:
            cal = self.calibrations[(gridx,gridy)][1]
        return cal.translate(x1,y1)
        

if __name__ == "__main__":
        
    a = MSACalibration()

    a.storeReading(0.0,0.0,0.0,0.0)
    a.storeReading(10.0,0.0,1000.0,0.0)
    a.storeReading(0.0,10.0,0.0,10.0)
    a.compute()

    print a.translate(5,5)#500, 5


